<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://devin0x01.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://devin0x01.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/light.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/syntax.css' />
    <title>Linux网络编程 - DEVIN 0x01</title>
    
    <link rel="icon" type="image/x-icon" href='https://devin0x01.github.io/images/favicon.ico'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="查看端口占用情况 netstat -tunlp
-t (tcp) 仅显示tcp相关选项 -u (udp) 仅显示udp相关选项
-n 拒绝显示列名，能显示数字的全部转化为数字
-l 仅显示出在listen(监听）的服务状态
-p 显示潜力相关链接的程序名
linux查看端口被哪个进程占用的方法
本机地址 127.0.0.1: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在同一台机器上。
INADDR_ANY: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示所有的网卡IP地址的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为192.168.10.128
PC1中sever监听127.0.0.1，则PC1中的client可以连上127.0.0.1，192.168.10.128连不上；而PC2中client都连不上。 PC1中sever监听192.168.10.128，则PC1中的client可以连上192.168.10.128，127.0.0.1连不上；而PC2中client能连上192.168.10.128。 PC1中sever监听0.0.0.0，则PC1中的client可以连上127.0.0.1和192.168.10.128，PC2中的client能连上192.168.10.128。 socket基础接口 close关闭socket 调用close函数，会向连接的对应套接字发送EOF (ch04/echo_server.c)
文件结束符：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
终端特殊字符：EOF 是传统模式下的文件结尾字符（通常是 Ctrl-D）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。
shutdown优雅的断开TCP连接 /* Shut down all or part of the connection open on socket FD. HOW determines what to shut down: SHUT_RD = No more receptions; SHUT_WR = No more transmissions; SHUT_RDWR = No more receptions or transmissions." />
<meta name="keywords"
  content='' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://devin0x01.github.io/post/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Linux网络编程 - DEVIN 0x01" />
<meta name="twitter:description"
  content="查看端口占用情况 netstat -tunlp
-t (tcp) 仅显示tcp相关选项 -u (udp) 仅显示udp相关选项
-n 拒绝显示列名，能显示数字的全部转化为数字
-l 仅显示出在listen(监听）的服务状态
-p 显示潜力相关链接的程序名
linux查看端口被哪个进程占用的方法
本机地址 127.0.0.1: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在同一台机器上。
INADDR_ANY: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示所有的网卡IP地址的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为192.168.10.128
PC1中sever监听127.0.0.1，则PC1中的client可以连上127.0.0.1，192.168.10.128连不上；而PC2中client都连不上。 PC1中sever监听192.168.10.128，则PC1中的client可以连上192.168.10.128，127.0.0.1连不上；而PC2中client能连上192.168.10.128。 PC1中sever监听0.0.0.0，则PC1中的client可以连上127.0.0.1和192.168.10.128，PC2中的client能连上192.168.10.128。 socket基础接口 close关闭socket 调用close函数，会向连接的对应套接字发送EOF (ch04/echo_server.c)
文件结束符：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
终端特殊字符：EOF 是传统模式下的文件结尾字符（通常是 Ctrl-D）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。
shutdown优雅的断开TCP连接 /* Shut down all or part of the connection open on socket FD. HOW determines what to shut down: SHUT_RD = No more receptions; SHUT_WR = No more transmissions; SHUT_RDWR = No more receptions or transmissions." />
<meta name="twitter:site" content="https://devin0x01.github.io" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://devin0x01.github.io">


<meta property="og:type" content="article" />
<meta property="og:title" content="Linux网络编程 - DEVIN 0x01">
<meta property="og:description"
  content="查看端口占用情况 netstat -tunlp
-t (tcp) 仅显示tcp相关选项 -u (udp) 仅显示udp相关选项
-n 拒绝显示列名，能显示数字的全部转化为数字
-l 仅显示出在listen(监听）的服务状态
-p 显示潜力相关链接的程序名
linux查看端口被哪个进程占用的方法
本机地址 127.0.0.1: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在同一台机器上。
INADDR_ANY: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示所有的网卡IP地址的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为192.168.10.128
PC1中sever监听127.0.0.1，则PC1中的client可以连上127.0.0.1，192.168.10.128连不上；而PC2中client都连不上。 PC1中sever监听192.168.10.128，则PC1中的client可以连上192.168.10.128，127.0.0.1连不上；而PC2中client能连上192.168.10.128。 PC1中sever监听0.0.0.0，则PC1中的client可以连上127.0.0.1和192.168.10.128，PC2中的client能连上192.168.10.128。 socket基础接口 close关闭socket 调用close函数，会向连接的对应套接字发送EOF (ch04/echo_server.c)
文件结束符：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
终端特殊字符：EOF 是传统模式下的文件结尾字符（通常是 Ctrl-D）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。
shutdown优雅的断开TCP连接 /* Shut down all or part of the connection open on socket FD. HOW determines what to shut down: SHUT_RD = No more receptions; SHUT_WR = No more transmissions; SHUT_RDWR = No more receptions or transmissions." />
<meta property="og:url" content="https://devin0x01.github.io/post/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" />
<meta property="og:site_name" content="Linux网络编程" />
<meta property="og:image"
  content="https://devin0x01.github.io">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2023-06-18 14:05:25 &#43;0800 &#43;0800" />










</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://devin0x01.github.io">
        <svg class="octicon" height="32" viewBox="0 0 16 16" version="1.1" width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://devin0x01.github.io">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://devin0x01.github.io">
        <svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" version="1.1"
          width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>
  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://devin0x01.github.io">
                  <img class=" avatar-user"
                    src="https://devin0x01.github.io/images/avatar.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://devin0x01.github.io"></a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://devin0x01.github.io/post/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Linux网络编程</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Sun, 18 Jun 2023 14:05:25 &#43;0800"
                    class="no-wrap">
                    Sun, 18 Jun 2023 14:05:25 &#43;0800</relative-time>

                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      3441 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/linux%E5%BC%80%E5%8F%91">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      Linux开发
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h2 id="查看端口占用情况">查看端口占用情况</h2>
<blockquote>
<p><strong>netstat -tunlp</strong></p>
<p>-t (tcp) 仅显示tcp相关选项     -u (udp) 仅显示udp相关选项</p>
<p>-n 拒绝显示列名，能显示数字的全部转化为数字</p>
<p>-l 仅显示出在listen(监听）的服务状态</p>
<p>-p 显示潜力相关链接的程序名</p>
</blockquote>
<p><a href="https://www.yisu.com/zixun/311818.html">linux查看端口被哪个进程占用的方法</a></p>
<h2 id="本机地址">本机地址</h2>
<blockquote>
<p><strong>127.0.0.1</strong>: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在<strong>同一台机器上</strong>。</p>
<p><strong>INADDR_ANY</strong>: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示<strong>所有的网卡IP地址</strong>的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。</p>
</blockquote>
<p>如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为<code>192.168.10.128</code></p>
<ul>
<li>PC1中sever监听<code>127.0.0.1</code>，则PC1中的client可以连上<code>127.0.0.1</code>，<code>192.168.10.128</code>连不上；而PC2中client都连不上。</li>
<li>PC1中sever监听<code>192.168.10.128</code>，则PC1中的client可以连上<code>192.168.10.128</code>，<code>127.0.0.1</code>连不上；而PC2中client能连上<code>192.168.10.128</code>。</li>
<li>PC1中sever监听<code>0.0.0.0</code>，则PC1中的client可以连上<code>127.0.0.1</code>和<code>192.168.10.128</code>，PC2中的client能连上<code>192.168.10.128</code>。</li>
</ul>
<h2 id="socket基础接口">socket基础接口</h2>
<h3 id="close关闭socket">close关闭socket</h3>
<p>调用<code>close</code>函数，会向连接的对应套接字发送<code>EOF</code> (<em>ch04/echo_server.c</em>)</p>
<blockquote>
<p><strong>文件结束符</strong>：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。</p>
<p><strong>终端特殊字符</strong>：EOF 是传统模式下的文件结尾字符（通常是 <strong>Ctrl-D</strong>）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/devin0x01/myimages@master/githubpages/image_bb12f6be8f2d72b768f70889cd3d83c8.png" alt=""></p>
<h3 id="shutdown优雅的断开tcp连接">shutdown优雅的断开TCP连接</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Shut down all or part of the connection open on socket FD.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   HOW determines what to shut down:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     SHUT_RD   = No more receptions;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     SHUT_WR   = No more transmissions;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     SHUT_RDWR = No more receptions or transmissions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   Returns 0 on success, -1 for errors.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">shutdown</span> (<span style="color:#66d9ef">int</span> __fd, <span style="color:#66d9ef">int</span> __how) __THROW;
</span></span></code></pre></div><h2 id="io复用">IO复用</h2>
<h3 id="1select接口">1.select接口</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// echo_client.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUF_SIZE 1024
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> message[BUF_SIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> str_len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> serv_adr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Usage : %s &lt;IP&gt; &lt;port&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sock <span style="color:#f92672">=</span> socket(PF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sock <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;socket() error&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(serv_adr));
</span></span><span style="display:flex;"><span>    serv_adr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_adr.sin_addr.s_addr <span style="color:#f92672">=</span> inet_addr(argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    serv_adr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">2</span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (connect(sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#66d9ef">sizeof</span>(serv_adr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;connect() error!&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        puts(<span style="color:#e6db74">&#34;Connected...........&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        fputs(<span style="color:#e6db74">&#34;Input message(Q to quit): &#34;</span>, stdout);
</span></span><span style="display:flex;"><span>        fgets(message, BUF_SIZE, stdin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>strcmp(message, <span style="color:#e6db74">&#34;q</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>strcmp(message, <span style="color:#e6db74">&#34;Q</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        write(sock, message, strlen(message));
</span></span><span style="display:flex;"><span>        str_len <span style="color:#f92672">=</span> read(sock, message, BUF_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        message[str_len] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Message from server: %s&#34;</span>, message);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(sock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fputs(message, stderr);
</span></span><span style="display:flex;"><span>    fputc(<span style="color:#e6db74">&#39;\n&#39;</span>, stderr);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// echo_selectserv.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/select.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUF_SIZE 100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> serv_sock, clnt_sock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> serv_adr, clnt_adr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span> timeout;
</span></span><span style="display:flex;"><span>    fd_set reads, cpy_reads;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    socklen_t adr_sz;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd_max, str_len, fd_num, i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[BUF_SIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Usage : %s &lt;port&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    serv_sock <span style="color:#f92672">=</span> socket(PF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(serv_adr));
</span></span><span style="display:flex;"><span>    serv_adr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_adr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);
</span></span><span style="display:flex;"><span>    serv_adr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bind(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#66d9ef">sizeof</span>(serv_adr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;bind() error&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (listen(serv_sock, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;listen() error&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    FD_ZERO(<span style="color:#f92672">&amp;</span>reads);
</span></span><span style="display:flex;"><span>    FD_SET(serv_sock, <span style="color:#f92672">&amp;</span>reads); <span style="color:#75715e">//注册服务端套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fd_max <span style="color:#f92672">=</span> serv_sock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cpy_reads <span style="color:#f92672">=</span> reads;
</span></span><span style="display:flex;"><span>        timeout.tv_sec <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>        timeout.tv_usec <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((fd_num <span style="color:#f92672">=</span> select(fd_max <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>cpy_reads, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>timeout)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">//开始监视,每次重新监听
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (fd_num <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> fd_max <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (FD_ISSET(i, <span style="color:#f92672">&amp;</span>cpy_reads)) <span style="color:#75715e">//查找发生变化的套接字文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> serv_sock) <span style="color:#75715e">//如果是服务端套接字时,受理连接请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    adr_sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(clnt_adr);
</span></span><span style="display:flex;"><span>                    clnt_sock <span style="color:#f92672">=</span> accept(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>clnt_adr, <span style="color:#f92672">&amp;</span>adr_sz);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    FD_SET(clnt_sock, <span style="color:#f92672">&amp;</span>reads); <span style="color:#75715e">//注册一个clnt_sock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (fd_max <span style="color:#f92672">&lt;</span> clnt_sock)
</span></span><span style="display:flex;"><span>                        fd_max <span style="color:#f92672">=</span> clnt_sock;
</span></span><span style="display:flex;"><span>                    printf(<span style="color:#e6db74">&#34;Connected client: %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, clnt_sock);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#75715e">//不是服务端套接字时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    str_len <span style="color:#f92672">=</span> read(i, buf, BUF_SIZE); <span style="color:#75715e">//i指的是当前发起请求的客户端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (str_len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        FD_CLR(i, <span style="color:#f92672">&amp;</span>reads);
</span></span><span style="display:flex;"><span>                        close(i);
</span></span><span style="display:flex;"><span>                        printf(<span style="color:#e6db74">&#34;closed client: %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        write(i, buf, str_len);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(serv_sock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fputs(message, stderr);
</span></span><span style="display:flex;"><span>    fputc(<span style="color:#e6db74">&#39;\n&#39;</span>, stderr);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">select</span>(<span style="color:#66d9ef">int</span> maxfds, fd_set <span style="color:#f92672">*</span>readfds, fd_set <span style="color:#f92672">*</span>writefds, fd_set <span style="color:#f92672">*</span>exceptfds,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span> <span style="color:#f92672">*</span>__timeout);
</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/devin0x01/myimages@master/githubpages/image_122999c4ec9f2f1b4a88eee6165a9de4.png" alt=""></p>
<h3 id="2epoll系列接口">2.epoll系列接口</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 水平触发 echo_EPLTserv.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUF_SIZE 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define EPOLL_SIZE 50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> serv_sock, clnt_sock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> serv_adr, clnt_adr;
</span></span><span style="display:flex;"><span>    socklen_t adr_sz;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> str_len, i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[BUF_SIZE];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> <span style="color:#f92672">*</span>ep_events;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> event;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> epfd, event_cnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Usage : %s &lt;port&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    serv_sock <span style="color:#f92672">=</span> socket(PF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(serv_adr));
</span></span><span style="display:flex;"><span>    serv_adr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_adr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);
</span></span><span style="display:flex;"><span>    serv_adr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bind(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#66d9ef">sizeof</span>(serv_adr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;bind() error&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (listen(serv_sock, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;listen() error&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    epfd <span style="color:#f92672">=</span> epoll_create(EPOLL_SIZE); <span style="color:#75715e">//可以忽略这个参数，填入的参数为操作系统参考
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ep_events <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span>) <span style="color:#f92672">*</span> EPOLL_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    event.events <span style="color:#f92672">=</span> EPOLLIN; <span style="color:#75715e">//需要读取数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    event.data.fd <span style="color:#f92672">=</span> serv_sock;
</span></span><span style="display:flex;"><span>    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, <span style="color:#f92672">&amp;</span>event); <span style="color:#75715e">//例程epfd 中添加文件描述符 serv_sock，目的是监听 enevt 中的事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        event_cnt <span style="color:#f92672">=</span> epoll_wait(epfd, ep_events, EPOLL_SIZE, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//获取改变了的文件描述符，返回数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (event_cnt <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            puts(<span style="color:#e6db74">&#34;epoll_wait() error&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        puts(<span style="color:#e6db74">&#34;return epoll_wait&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> event_cnt; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ep_events[i].data.fd <span style="color:#f92672">==</span> serv_sock) <span style="color:#75715e">//客户端请求连接时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                adr_sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(clnt_adr);
</span></span><span style="display:flex;"><span>                clnt_sock <span style="color:#f92672">=</span> accept(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>clnt_adr, <span style="color:#f92672">&amp;</span>adr_sz);
</span></span><span style="display:flex;"><span>                event.events <span style="color:#f92672">=</span> EPOLLIN;
</span></span><span style="display:flex;"><span>                event.data.fd <span style="color:#f92672">=</span> clnt_sock; <span style="color:#75715e">//把客户端套接字添加进去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, <span style="color:#f92672">&amp;</span>event);
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;connected client : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, clnt_sock);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#75715e">//是客户端套接字时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                str_len <span style="color:#f92672">=</span> read(ep_events[i].data.fd, buf, BUF_SIZE);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (str_len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); <span style="color:#75715e">//从epoll中删除套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    close(ep_events[i].data.fd);
</span></span><span style="display:flex;"><span>                    printf(<span style="color:#e6db74">&#34;closed client : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ep_events[i].data.fd);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    write(ep_events[i].data.fd, buf, str_len);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(serv_sock);
</span></span><span style="display:flex;"><span>    close(epfd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fputs(message, stderr);
</span></span><span style="display:flex;"><span>    fputc(<span style="color:#e6db74">&#39;\n&#39;</span>, stderr);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 边沿触发 echo_EPETserv.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;errno.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUF_SIZE 4 </span><span style="color:#75715e">//缓冲区设置为 4 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EPOLL_SIZE 50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setnonblockingmode</span>(<span style="color:#66d9ef">int</span> fd);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> serv_sock, clnt_sock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> serv_adr, clnt_adr;
</span></span><span style="display:flex;"><span>    socklen_t adr_sz;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> str_len, i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[BUF_SIZE];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> <span style="color:#f92672">*</span>ep_events;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> event;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> epfd, event_cnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Usage : %s &lt;port&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    serv_sock <span style="color:#f92672">=</span> socket(PF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(serv_adr));
</span></span><span style="display:flex;"><span>    serv_adr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_adr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);
</span></span><span style="display:flex;"><span>    serv_adr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bind(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#66d9ef">sizeof</span>(serv_adr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;bind() error&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (listen(serv_sock, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;listen() error&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    epfd <span style="color:#f92672">=</span> epoll_create(EPOLL_SIZE); <span style="color:#75715e">//可以忽略这个参数，填入的参数为操作系统参考
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ep_events <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span>) <span style="color:#f92672">*</span> EPOLL_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    setnonblockingmode(serv_sock);
</span></span><span style="display:flex;"><span>    event.events <span style="color:#f92672">=</span> EPOLLIN; <span style="color:#75715e">//需要读取数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    event.data.fd <span style="color:#f92672">=</span> serv_sock;
</span></span><span style="display:flex;"><span>    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, <span style="color:#f92672">&amp;</span>event); <span style="color:#75715e">//例程epfd 中添加文件描述符 serv_sock，目的是监听 enevt 中的事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        event_cnt <span style="color:#f92672">=</span> epoll_wait(epfd, ep_events, EPOLL_SIZE, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//获取改变了的文件描述符，返回数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (event_cnt <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            puts(<span style="color:#e6db74">&#34;epoll_wait() error&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        puts(<span style="color:#e6db74">&#34;return epoll_wait&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> event_cnt; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ep_events[i].data.fd <span style="color:#f92672">==</span> serv_sock) <span style="color:#75715e">//客户端请求连接时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                adr_sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(clnt_adr);
</span></span><span style="display:flex;"><span>                clnt_sock <span style="color:#f92672">=</span> accept(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>clnt_adr, <span style="color:#f92672">&amp;</span>adr_sz);
</span></span><span style="display:flex;"><span>                setnonblockingmode(clnt_sock);    <span style="color:#75715e">//将 accept 创建的套接字改为非阻塞模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                event.events <span style="color:#f92672">=</span> EPOLLIN <span style="color:#f92672">|</span> EPOLLET; <span style="color:#75715e">//改成边缘触发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                event.data.fd <span style="color:#f92672">=</span> clnt_sock;        <span style="color:#75715e">//把客户端套接字添加进去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, <span style="color:#f92672">&amp;</span>event);
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;connected client : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, clnt_sock);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#75715e">//是客户端套接字时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    str_len <span style="color:#f92672">=</span> read(ep_events[i].data.fd, buf, BUF_SIZE);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (str_len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); <span style="color:#75715e">//从epoll中删除套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        close(ep_events[i].data.fd);
</span></span><span style="display:flex;"><span>                        printf(<span style="color:#e6db74">&#34;closed client : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ep_events[i].data.fd);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (str_len <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EAGAIN) <span style="color:#75715e">//read 返回-1 且 errno 值为 EAGAIN ，意味读取了输入缓冲的全部数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        write(ep_events[i].data.fd, buf, str_len);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(serv_sock);
</span></span><span style="display:flex;"><span>    close(epfd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fputs(message, stderr);
</span></span><span style="display:flex;"><span>    fputc(<span style="color:#e6db74">&#39;\n&#39;</span>, stderr);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setnonblockingmode</span>(<span style="color:#66d9ef">int</span> fd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> fcntl(fd, F_GETFL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    fcntl(fd, F_SETFL, flag <span style="color:#f92672">|</span> O_NONBLOCK);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// size: epoll实例监听的文件描述符数目。Linux2.6.8之后这个参数可以忽略。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// retval: epoll实例文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_create</span>(<span style="color:#66d9ef">int</span> size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// op: EPOLL_CTL_ADD, EPOLL_CTL_DEL, EPOLL_CTL_MOD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_ctl</span>(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">int</span> op, <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> <span style="color:#f92672">*</span>event)<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// events: 保存发生事件的文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// maxevents: 第二个参数可以保存的最大事件数，即数组大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> epoll_wait(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> <span style="color:#f92672">*</span>events, <span style="color:#66d9ef">int</span> maxevents, <span style="color:#66d9ef">int</span> timeout);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">epoll_data</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> fd;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> u32;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> u64;
</span></span><span style="display:flex;"><span>} epoll_data_t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// events支持的事件类型：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLIN: 需要读取数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLOUT: 输出缓存为空，可以理解发送数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLPRI: 收到OOB数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLRDHUP: 断开连接或半关闭的情况，这在边缘触发方式下非常有用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLERR: 发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLET: 以边沿触发的方式得到事件通知
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLONESHOT: 发生一次事件后，相应文件描述符不再收到事件通知。因此需要先epoll_ctl函数的第2个参数传递EPOLL_CTL_MOD再次设置事件。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> events;	<span style="color:#75715e">/* Epoll events */</span>
</span></span><span style="display:flex;"><span>  epoll_data_t data;	<span style="color:#75715e">/* User data variable */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p>1.为什么不可以同时设置<code>event.events = EPOLLIN | EPOLLOUT</code>？</p>
<p>最主要的是这句：at the time of the callback, epoll has no clue of what happened。大概指的回调的时候，<code>epoll</code>是不能区分出是<code>EPOLLIN</code>还是<code>EPOLLOUT</code>的。换句话说如果你同时监听了<code>EPOLLIN</code>和<code>EPOLLOUT</code>，当发生了<code>EPOLLIN</code>，由于<code>epoll</code>无法区分种类，那么将会同时监听到<code>EPOLLIN</code>和<code>EPOLLOUT</code>事件（即使当时没有发生EPOLLOUT）。</p>
<p>2.什么时候设置为<code>EPOLLOUT</code>呢？</p>
<p>当需要发送数据的时候，可以使用<code>epoll_ctl</code>来注册事件，第3个参数可以设置为<code>event-&gt;events = EPOLLOUT; event-&gt;data.ptr = dataToBeSent</code>，其中<code>dataToBeSent</code>可以为自定义结构<code>struct { int fd; char *buf; }</code>。当发生<code>EPOLLOUT</code>时候表示可以继续写入，直到发送完毕，然后再设置为<code>EPOLLIN</code>。</p>
<p><a href="https://www.jianshu.com/p/f1eae48c1211">EPOLL讲解、注意点和使用建议 - 简书 (jianshu.com)</a></p>
</blockquote>
<p><strong>epoll默认是水平触发模式。边沿触发ET相比于水平触发LT，改动的地方主要有2处：</strong></p>
<ul>
<li>设置为fd为非阻塞IO</li>
<li>读取时需要使用while(1)读取，读取完成后read返回-1而且errno==EAGAIN</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/devin0x01/myimages@master/githubpages/image_90475ad986a2c3183867e607e0799f3c.png" alt=""></p>
<h3 id="3select和epoll的比较">3.select和epoll的比较</h3>
<blockquote>
<p>1.select相比epoll的速度慢的原因：</p>
<ul>
<li>
<p>调用select函数后需要遍历所有文件描述符</p>
</li>
<li>
<p>每次调用select函数时，都需要向该函数传递监视对象信息。</p>
</li>
</ul>
<p>2.select相比epoll的<strong>优势</strong>：</p>
<ul>
<li>epoll只支持Linux平台，而select支持大部分操作系统。因此服务端接入这比较少时适用。</li>
</ul>
</blockquote>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://devin0x01.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://devin0x01.github.io/css/toc.css' />


  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://devin0x01.github.io">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://devin0x01.github.io/js/github-style.js"></script>




</html>