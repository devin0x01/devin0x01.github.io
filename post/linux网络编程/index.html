<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Linux网络编程 - DEVIN&#39;s BLOG</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux网络编程" />
<meta property="og:description" content="查看端口占用情况 netstat -tunlp
-t (tcp) 仅显示tcp相关选项 -u (udp) 仅显示udp相关选项
-n 拒绝显示列名，能显示数字的全部转化为数字
-l 仅显示出在listen(监听）的服务状态
-p 显示潜力相关链接的程序名
linux查看端口被哪个进程占用的方法
本机地址 127.0.0.1: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在同一台机器上。
INADDR_ANY: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示所有的网卡IP地址的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为192.168.10.128
PC1中sever监听127.0.0.1，则PC1中的client可以连上127.0.0.1，192.168.10.128连不上；而PC2中client都连不上。 PC1中sever监听192.168.10.128，则PC1中的client可以连上192.168.10.128，127.0.0.1连不上；而PC2中client能连上192.168.10.128。 PC1中sever监听0.0.0.0，则PC1中的client可以连上127.0.0.1和192.168.10.128，PC2中的client能连上192.168.10.128。 socket基础接口 close关闭socket 调用close函数，会向连接的对应套接字发送EOF (ch04/echo_server.c)
文件结束符：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
终端特殊字符：EOF 是传统模式下的文件结尾字符（通常是 Ctrl-D）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。
shutdown优雅的断开TCP连接 /* Shut down all or part of the connection open on socket FD. HOW determines what to shut down: SHUT_RD = No more receptions; SHUT_WR = No more transmissions; SHUT_RDWR = No more receptions or transmissions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://devin0x01.github.io/post/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-06-18T14:05:25+08:00" />
<meta property="article:modified_time" content="2023-06-18T14:05:25+08:00" />

		<meta itemprop="name" content="Linux网络编程">
<meta itemprop="description" content="查看端口占用情况 netstat -tunlp
-t (tcp) 仅显示tcp相关选项 -u (udp) 仅显示udp相关选项
-n 拒绝显示列名，能显示数字的全部转化为数字
-l 仅显示出在listen(监听）的服务状态
-p 显示潜力相关链接的程序名
linux查看端口被哪个进程占用的方法
本机地址 127.0.0.1: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在同一台机器上。
INADDR_ANY: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示所有的网卡IP地址的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为192.168.10.128
PC1中sever监听127.0.0.1，则PC1中的client可以连上127.0.0.1，192.168.10.128连不上；而PC2中client都连不上。 PC1中sever监听192.168.10.128，则PC1中的client可以连上192.168.10.128，127.0.0.1连不上；而PC2中client能连上192.168.10.128。 PC1中sever监听0.0.0.0，则PC1中的client可以连上127.0.0.1和192.168.10.128，PC2中的client能连上192.168.10.128。 socket基础接口 close关闭socket 调用close函数，会向连接的对应套接字发送EOF (ch04/echo_server.c)
文件结束符：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
终端特殊字符：EOF 是传统模式下的文件结尾字符（通常是 Ctrl-D）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。
shutdown优雅的断开TCP连接 /* Shut down all or part of the connection open on socket FD. HOW determines what to shut down: SHUT_RD = No more receptions; SHUT_WR = No more transmissions; SHUT_RDWR = No more receptions or transmissions."><meta itemprop="datePublished" content="2023-06-18T14:05:25+08:00" />
<meta itemprop="dateModified" content="2023-06-18T14:05:25+08:00" />
<meta itemprop="wordCount" content="1154">
<meta itemprop="keywords" content="Linux开发," />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux网络编程"/>
<meta name="twitter:description" content="查看端口占用情况 netstat -tunlp
-t (tcp) 仅显示tcp相关选项 -u (udp) 仅显示udp相关选项
-n 拒绝显示列名，能显示数字的全部转化为数字
-l 仅显示出在listen(监听）的服务状态
-p 显示潜力相关链接的程序名
linux查看端口被哪个进程占用的方法
本机地址 127.0.0.1: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在同一台机器上。
INADDR_ANY: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示所有的网卡IP地址的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为192.168.10.128
PC1中sever监听127.0.0.1，则PC1中的client可以连上127.0.0.1，192.168.10.128连不上；而PC2中client都连不上。 PC1中sever监听192.168.10.128，则PC1中的client可以连上192.168.10.128，127.0.0.1连不上；而PC2中client能连上192.168.10.128。 PC1中sever监听0.0.0.0，则PC1中的client可以连上127.0.0.1和192.168.10.128，PC2中的client能连上192.168.10.128。 socket基础接口 close关闭socket 调用close函数，会向连接的对应套接字发送EOF (ch04/echo_server.c)
文件结束符：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
终端特殊字符：EOF 是传统模式下的文件结尾字符（通常是 Ctrl-D）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。
shutdown优雅的断开TCP连接 /* Shut down all or part of the connection open on socket FD. HOW determines what to shut down: SHUT_RD = No more receptions; SHUT_WR = No more transmissions; SHUT_RDWR = No more receptions or transmissions."/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="LogoTitle" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/img/placeholder.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">LogoTitle</div>
					<div class="logo__tagline">Just another site</div>
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux网络编程</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Devin</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2023-06-18T14:05:25&#43;08:00">2023-06-18</time></div></div>
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#查看端口占用情况">查看端口占用情况</a></li>
    <li><a href="#本机地址">本机地址</a></li>
    <li><a href="#socket基础接口">socket基础接口</a>
      <ul>
        <li><a href="#close关闭socket">close关闭socket</a></li>
        <li><a href="#shutdown优雅的断开tcp连接">shutdown优雅的断开TCP连接</a></li>
      </ul>
    </li>
    <li><a href="#io复用">IO复用</a>
      <ul>
        <li><a href="#1select接口">1.select接口</a></li>
        <li><a href="#2epoll系列接口">2.epoll系列接口</a></li>
        <li><a href="#3select和epoll的比较">3.select和epoll的比较</a></li>
      </ul>
    </li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<h2 id="查看端口占用情况">查看端口占用情况</h2>
<blockquote>
<p><strong>netstat -tunlp</strong></p>
<p>-t (tcp) 仅显示tcp相关选项     -u (udp) 仅显示udp相关选项</p>
<p>-n 拒绝显示列名，能显示数字的全部转化为数字</p>
<p>-l 仅显示出在listen(监听）的服务状态</p>
<p>-p 显示潜力相关链接的程序名</p>
</blockquote>
<p><a href="https://www.yisu.com/zixun/311818.html">linux查看端口被哪个进程占用的方法</a></p>
<h2 id="本机地址">本机地址</h2>
<blockquote>
<p><strong>127.0.0.1</strong>: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在<strong>同一台机器上</strong>。</p>
<p><strong>INADDR_ANY</strong>: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示<strong>所有的网卡IP地址</strong>的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。</p>
</blockquote>
<p>如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为<code>192.168.10.128</code></p>
<ul>
<li>PC1中sever监听<code>127.0.0.1</code>，则PC1中的client可以连上<code>127.0.0.1</code>，<code>192.168.10.128</code>连不上；而PC2中client都连不上。</li>
<li>PC1中sever监听<code>192.168.10.128</code>，则PC1中的client可以连上<code>192.168.10.128</code>，<code>127.0.0.1</code>连不上；而PC2中client能连上<code>192.168.10.128</code>。</li>
<li>PC1中sever监听<code>0.0.0.0</code>，则PC1中的client可以连上<code>127.0.0.1</code>和<code>192.168.10.128</code>，PC2中的client能连上<code>192.168.10.128</code>。</li>
</ul>
<h2 id="socket基础接口">socket基础接口</h2>
<h3 id="close关闭socket">close关闭socket</h3>
<p>调用<code>close</code>函数，会向连接的对应套接字发送<code>EOF</code> (<em>ch04/echo_server.c</em>)</p>
<blockquote>
<p><strong>文件结束符</strong>：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。</p>
<p><strong>终端特殊字符</strong>：EOF 是传统模式下的文件结尾字符（通常是 <strong>Ctrl-D</strong>）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/devin0x01/myimages@master/githubpages/image_bb12f6be8f2d72b768f70889cd3d83c8.png" alt=""></p>
<h3 id="shutdown优雅的断开tcp连接">shutdown优雅的断开TCP连接</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Shut down all or part of the connection open on socket FD.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   HOW determines what to shut down:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     SHUT_RD   = No more receptions;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     SHUT_WR   = No more transmissions;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     SHUT_RDWR = No more receptions or transmissions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   Returns 0 on success, -1 for errors.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">shutdown</span> (<span style="color:#66d9ef">int</span> __fd, <span style="color:#66d9ef">int</span> __how) __THROW;
</span></span></code></pre></div><h2 id="io复用">IO复用</h2>
<h3 id="1select接口">1.select接口</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// echo_client.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUF_SIZE 1024
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> message[BUF_SIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> str_len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> serv_adr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Usage : %s &lt;IP&gt; &lt;port&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sock <span style="color:#f92672">=</span> socket(PF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sock <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;socket() error&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(serv_adr));
</span></span><span style="display:flex;"><span>    serv_adr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_adr.sin_addr.s_addr <span style="color:#f92672">=</span> inet_addr(argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    serv_adr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">2</span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (connect(sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#66d9ef">sizeof</span>(serv_adr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;connect() error!&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        puts(<span style="color:#e6db74">&#34;Connected...........&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        fputs(<span style="color:#e6db74">&#34;Input message(Q to quit): &#34;</span>, stdout);
</span></span><span style="display:flex;"><span>        fgets(message, BUF_SIZE, stdin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>strcmp(message, <span style="color:#e6db74">&#34;q</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>strcmp(message, <span style="color:#e6db74">&#34;Q</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        write(sock, message, strlen(message));
</span></span><span style="display:flex;"><span>        str_len <span style="color:#f92672">=</span> read(sock, message, BUF_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        message[str_len] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Message from server: %s&#34;</span>, message);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(sock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fputs(message, stderr);
</span></span><span style="display:flex;"><span>    fputc(<span style="color:#e6db74">&#39;\n&#39;</span>, stderr);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// echo_selectserv.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/select.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUF_SIZE 100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> serv_sock, clnt_sock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> serv_adr, clnt_adr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span> timeout;
</span></span><span style="display:flex;"><span>    fd_set reads, cpy_reads;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    socklen_t adr_sz;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd_max, str_len, fd_num, i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[BUF_SIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Usage : %s &lt;port&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    serv_sock <span style="color:#f92672">=</span> socket(PF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(serv_adr));
</span></span><span style="display:flex;"><span>    serv_adr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_adr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);
</span></span><span style="display:flex;"><span>    serv_adr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bind(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#66d9ef">sizeof</span>(serv_adr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;bind() error&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (listen(serv_sock, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;listen() error&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    FD_ZERO(<span style="color:#f92672">&amp;</span>reads);
</span></span><span style="display:flex;"><span>    FD_SET(serv_sock, <span style="color:#f92672">&amp;</span>reads); <span style="color:#75715e">//注册服务端套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fd_max <span style="color:#f92672">=</span> serv_sock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cpy_reads <span style="color:#f92672">=</span> reads;
</span></span><span style="display:flex;"><span>        timeout.tv_sec <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>        timeout.tv_usec <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((fd_num <span style="color:#f92672">=</span> select(fd_max <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>cpy_reads, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>timeout)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">//开始监视,每次重新监听
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (fd_num <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> fd_max <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (FD_ISSET(i, <span style="color:#f92672">&amp;</span>cpy_reads)) <span style="color:#75715e">//查找发生变化的套接字文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> serv_sock) <span style="color:#75715e">//如果是服务端套接字时,受理连接请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    adr_sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(clnt_adr);
</span></span><span style="display:flex;"><span>                    clnt_sock <span style="color:#f92672">=</span> accept(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>clnt_adr, <span style="color:#f92672">&amp;</span>adr_sz);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    FD_SET(clnt_sock, <span style="color:#f92672">&amp;</span>reads); <span style="color:#75715e">//注册一个clnt_sock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (fd_max <span style="color:#f92672">&lt;</span> clnt_sock)
</span></span><span style="display:flex;"><span>                        fd_max <span style="color:#f92672">=</span> clnt_sock;
</span></span><span style="display:flex;"><span>                    printf(<span style="color:#e6db74">&#34;Connected client: %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, clnt_sock);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#75715e">//不是服务端套接字时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    str_len <span style="color:#f92672">=</span> read(i, buf, BUF_SIZE); <span style="color:#75715e">//i指的是当前发起请求的客户端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (str_len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        FD_CLR(i, <span style="color:#f92672">&amp;</span>reads);
</span></span><span style="display:flex;"><span>                        close(i);
</span></span><span style="display:flex;"><span>                        printf(<span style="color:#e6db74">&#34;closed client: %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        write(i, buf, str_len);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(serv_sock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fputs(message, stderr);
</span></span><span style="display:flex;"><span>    fputc(<span style="color:#e6db74">&#39;\n&#39;</span>, stderr);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">select</span>(<span style="color:#66d9ef">int</span> maxfds, fd_set <span style="color:#f92672">*</span>readfds, fd_set <span style="color:#f92672">*</span>writefds, fd_set <span style="color:#f92672">*</span>exceptfds,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span> <span style="color:#f92672">*</span>__timeout);
</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/devin0x01/myimages@master/githubpages/image_122999c4ec9f2f1b4a88eee6165a9de4.png" alt=""></p>
<h3 id="2epoll系列接口">2.epoll系列接口</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 水平触发 echo_EPLTserv.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUF_SIZE 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define EPOLL_SIZE 50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> serv_sock, clnt_sock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> serv_adr, clnt_adr;
</span></span><span style="display:flex;"><span>    socklen_t adr_sz;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> str_len, i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[BUF_SIZE];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> <span style="color:#f92672">*</span>ep_events;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> event;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> epfd, event_cnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Usage : %s &lt;port&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    serv_sock <span style="color:#f92672">=</span> socket(PF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(serv_adr));
</span></span><span style="display:flex;"><span>    serv_adr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_adr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);
</span></span><span style="display:flex;"><span>    serv_adr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bind(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#66d9ef">sizeof</span>(serv_adr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;bind() error&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (listen(serv_sock, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;listen() error&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    epfd <span style="color:#f92672">=</span> epoll_create(EPOLL_SIZE); <span style="color:#75715e">//可以忽略这个参数，填入的参数为操作系统参考
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ep_events <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span>) <span style="color:#f92672">*</span> EPOLL_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    event.events <span style="color:#f92672">=</span> EPOLLIN; <span style="color:#75715e">//需要读取数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    event.data.fd <span style="color:#f92672">=</span> serv_sock;
</span></span><span style="display:flex;"><span>    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, <span style="color:#f92672">&amp;</span>event); <span style="color:#75715e">//例程epfd 中添加文件描述符 serv_sock，目的是监听 enevt 中的事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        event_cnt <span style="color:#f92672">=</span> epoll_wait(epfd, ep_events, EPOLL_SIZE, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//获取改变了的文件描述符，返回数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (event_cnt <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            puts(<span style="color:#e6db74">&#34;epoll_wait() error&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        puts(<span style="color:#e6db74">&#34;return epoll_wait&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> event_cnt; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ep_events[i].data.fd <span style="color:#f92672">==</span> serv_sock) <span style="color:#75715e">//客户端请求连接时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                adr_sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(clnt_adr);
</span></span><span style="display:flex;"><span>                clnt_sock <span style="color:#f92672">=</span> accept(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>clnt_adr, <span style="color:#f92672">&amp;</span>adr_sz);
</span></span><span style="display:flex;"><span>                event.events <span style="color:#f92672">=</span> EPOLLIN;
</span></span><span style="display:flex;"><span>                event.data.fd <span style="color:#f92672">=</span> clnt_sock; <span style="color:#75715e">//把客户端套接字添加进去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, <span style="color:#f92672">&amp;</span>event);
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;connected client : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, clnt_sock);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#75715e">//是客户端套接字时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                str_len <span style="color:#f92672">=</span> read(ep_events[i].data.fd, buf, BUF_SIZE);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (str_len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); <span style="color:#75715e">//从epoll中删除套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    close(ep_events[i].data.fd);
</span></span><span style="display:flex;"><span>                    printf(<span style="color:#e6db74">&#34;closed client : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ep_events[i].data.fd);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    write(ep_events[i].data.fd, buf, str_len);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(serv_sock);
</span></span><span style="display:flex;"><span>    close(epfd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fputs(message, stderr);
</span></span><span style="display:flex;"><span>    fputc(<span style="color:#e6db74">&#39;\n&#39;</span>, stderr);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 边沿触发 echo_EPETserv.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;errno.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUF_SIZE 4 </span><span style="color:#75715e">//缓冲区设置为 4 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EPOLL_SIZE 50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setnonblockingmode</span>(<span style="color:#66d9ef">int</span> fd);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> serv_sock, clnt_sock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> serv_adr, clnt_adr;
</span></span><span style="display:flex;"><span>    socklen_t adr_sz;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> str_len, i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[BUF_SIZE];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> <span style="color:#f92672">*</span>ep_events;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> event;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> epfd, event_cnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Usage : %s &lt;port&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    serv_sock <span style="color:#f92672">=</span> socket(PF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(serv_adr));
</span></span><span style="display:flex;"><span>    serv_adr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_adr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);
</span></span><span style="display:flex;"><span>    serv_adr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bind(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>serv_adr, <span style="color:#66d9ef">sizeof</span>(serv_adr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;bind() error&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (listen(serv_sock, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        error_handling(<span style="color:#e6db74">&#34;listen() error&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    epfd <span style="color:#f92672">=</span> epoll_create(EPOLL_SIZE); <span style="color:#75715e">//可以忽略这个参数，填入的参数为操作系统参考
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ep_events <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span>) <span style="color:#f92672">*</span> EPOLL_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    setnonblockingmode(serv_sock);
</span></span><span style="display:flex;"><span>    event.events <span style="color:#f92672">=</span> EPOLLIN; <span style="color:#75715e">//需要读取数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    event.data.fd <span style="color:#f92672">=</span> serv_sock;
</span></span><span style="display:flex;"><span>    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, <span style="color:#f92672">&amp;</span>event); <span style="color:#75715e">//例程epfd 中添加文件描述符 serv_sock，目的是监听 enevt 中的事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        event_cnt <span style="color:#f92672">=</span> epoll_wait(epfd, ep_events, EPOLL_SIZE, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//获取改变了的文件描述符，返回数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (event_cnt <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            puts(<span style="color:#e6db74">&#34;epoll_wait() error&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        puts(<span style="color:#e6db74">&#34;return epoll_wait&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> event_cnt; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ep_events[i].data.fd <span style="color:#f92672">==</span> serv_sock) <span style="color:#75715e">//客户端请求连接时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                adr_sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(clnt_adr);
</span></span><span style="display:flex;"><span>                clnt_sock <span style="color:#f92672">=</span> accept(serv_sock, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>clnt_adr, <span style="color:#f92672">&amp;</span>adr_sz);
</span></span><span style="display:flex;"><span>                setnonblockingmode(clnt_sock);    <span style="color:#75715e">//将 accept 创建的套接字改为非阻塞模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                event.events <span style="color:#f92672">=</span> EPOLLIN <span style="color:#f92672">|</span> EPOLLET; <span style="color:#75715e">//改成边缘触发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                event.data.fd <span style="color:#f92672">=</span> clnt_sock;        <span style="color:#75715e">//把客户端套接字添加进去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, <span style="color:#f92672">&amp;</span>event);
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;connected client : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, clnt_sock);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#75715e">//是客户端套接字时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    str_len <span style="color:#f92672">=</span> read(ep_events[i].data.fd, buf, BUF_SIZE);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (str_len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); <span style="color:#75715e">//从epoll中删除套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        close(ep_events[i].data.fd);
</span></span><span style="display:flex;"><span>                        printf(<span style="color:#e6db74">&#34;closed client : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ep_events[i].data.fd);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (str_len <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EAGAIN) <span style="color:#75715e">//read 返回-1 且 errno 值为 EAGAIN ，意味读取了输入缓冲的全部数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        write(ep_events[i].data.fd, buf, str_len);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(serv_sock);
</span></span><span style="display:flex;"><span>    close(epfd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">error_handling</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fputs(message, stderr);
</span></span><span style="display:flex;"><span>    fputc(<span style="color:#e6db74">&#39;\n&#39;</span>, stderr);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setnonblockingmode</span>(<span style="color:#66d9ef">int</span> fd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> fcntl(fd, F_GETFL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    fcntl(fd, F_SETFL, flag <span style="color:#f92672">|</span> O_NONBLOCK);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// size: epoll实例监听的文件描述符数目。Linux2.6.8之后这个参数可以忽略。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// retval: epoll实例文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_create</span>(<span style="color:#66d9ef">int</span> size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// op: EPOLL_CTL_ADD, EPOLL_CTL_DEL, EPOLL_CTL_MOD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_ctl</span>(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">int</span> op, <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> <span style="color:#f92672">*</span>event)<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// events: 保存发生事件的文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// maxevents: 第二个参数可以保存的最大事件数，即数组大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> epoll_wait(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span> <span style="color:#f92672">*</span>events, <span style="color:#66d9ef">int</span> maxevents, <span style="color:#66d9ef">int</span> timeout);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">epoll_data</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> fd;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> u32;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> u64;
</span></span><span style="display:flex;"><span>} epoll_data_t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// events支持的事件类型：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLIN: 需要读取数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLOUT: 输出缓存为空，可以理解发送数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLPRI: 收到OOB数据的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLRDHUP: 断开连接或半关闭的情况，这在边缘触发方式下非常有用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLERR: 发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLET: 以边沿触发的方式得到事件通知
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// EPOLLONESHOT: 发生一次事件后，相应文件描述符不再收到事件通知。因此需要先epoll_ctl函数的第2个参数传递EPOLL_CTL_MOD再次设置事件。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">epoll_event</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> events;	<span style="color:#75715e">/* Epoll events */</span>
</span></span><span style="display:flex;"><span>  epoll_data_t data;	<span style="color:#75715e">/* User data variable */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p>1.为什么不可以同时设置<code>event.events = EPOLLIN | EPOLLOUT</code>？</p>
<p>最主要的是这句：at the time of the callback, epoll has no clue of what happened。大概指的回调的时候，<code>epoll</code>是不能区分出是<code>EPOLLIN</code>还是<code>EPOLLOUT</code>的。换句话说如果你同时监听了<code>EPOLLIN</code>和<code>EPOLLOUT</code>，当发生了<code>EPOLLIN</code>，由于<code>epoll</code>无法区分种类，那么将会同时监听到<code>EPOLLIN</code>和<code>EPOLLOUT</code>事件（即使当时没有发生EPOLLOUT）。</p>
<p>2.什么时候设置为<code>EPOLLOUT</code>呢？</p>
<p>当需要发送数据的时候，可以使用<code>epoll_ctl</code>来注册事件，第3个参数可以设置为<code>event-&gt;events = EPOLLOUT; event-&gt;data.ptr = dataToBeSent</code>，其中<code>dataToBeSent</code>可以为自定义结构<code>struct { int fd; char *buf; }</code>。当发生<code>EPOLLOUT</code>时候表示可以继续写入，直到发送完毕，然后再设置为<code>EPOLLIN</code>。</p>
<p><a href="https://www.jianshu.com/p/f1eae48c1211">EPOLL讲解、注意点和使用建议 - 简书 (jianshu.com)</a></p>
</blockquote>
<p><strong>epoll默认是水平触发模式。边沿触发ET相比于水平触发LT，改动的地方主要有2处：</strong></p>
<ul>
<li>设置为fd为非阻塞IO</li>
<li>读取时需要使用while(1)读取，读取完成后read返回-1而且errno==EAGAIN</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/devin0x01/myimages@master/githubpages/image_90475ad986a2c3183867e607e0799f3c.png" alt=""></p>
<h3 id="3select和epoll的比较">3.select和epoll的比较</h3>
<blockquote>
<p>1.select相比epoll的速度慢的原因：</p>
<ul>
<li>
<p>调用select函数后需要遍历所有文件描述符</p>
</li>
<li>
<p>每次调用select函数时，都需要向该函数传递监视对象信息。</p>
</li>
</ul>
<p>2.select相比epoll的<strong>优势</strong>：</p>
<ul>
<li>epoll只支持Linux平台，而select支持大部分操作系统。因此服务端接入这比较少时适用。</li>
</ul>
</blockquote>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/linux%E5%BC%80%E5%8F%91/" rel="tag">Linux开发</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Devin avatar" src="/img/avatar.png" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Devin</span>
	</div>
	<div class="authorbox__description">
		Devin&rsquo;s true identity is unknown. Maybe he is a successful blogger or writer. Nobody knows it.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/post/notepad&#43;&#43;%E6%9B%BF%E6%8D%A2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Notepad&#43;&#43;替换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/post/java%E5%9F%BA%E7%A1%80/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 Devin.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>