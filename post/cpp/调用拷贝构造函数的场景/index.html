<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://devin0x01.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://devin0x01.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/light.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://devin0x01.github.io/css/syntax.css' />
    <title>调用拷贝构造函数的场景 - DEVIN&#39;s BLOG</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="1.默认构造函数 默认构造函数是一个系统生成的，参数列表和函数体都为空的函数。 如果类中声明了默认构造函数（无论是否有参数），编译器便不再会为之生成隐含的构造函数。
2.析构函数 析构函数的函数列表为空，因此不能实现重载。 可以显式调用析构函数。例如可以通过对象名等进行调用，obj.~A(); 参考文献：显式调用析构函数
3.拷贝构造函数 拷贝构造函数的参数**必须是引用类型。**参数是指针不会编译报错，但是3.1中的场景不能触发调用拷贝构造函数。
3.1 调用拷贝构造函数的3种场景 用一个类的对象去初始化另一个类的对象时 Point a(1, 2); Point b(a); // 调用复制构造函数 Point c = a; // 调用复制构造函数 函数的形参是类对象，当调用函数，进行形参和实参结合时 void fun(Point obj) {} int main() { Point a(1, 2); fun(a); // 调用复制构造函数 } 如果函数的返回值是类对象，当函数执行完成返回调用者时 实际上，由于编译器的优化，可能不会调用。例如：gcc需要指定**-fno-elide-constructors**编译选项才会调用。
Point fun() { Point a(1, 2); return a; // 调用复制构造函数 } b = fun(); 4.赋值运算符 4.1 注意点 **拷贝构造函数必须以引用的方式传递参数，**基本上都是传常量引用的方式传递函数参数。 赋值运算符函数的返回值类型要声明为该类型的引用，并在函数结束前返回实例自身的的引用（this）*。**只有返回一个引用，才能进行连续赋值。否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。假设有3个Person对象：p1、p2、p3，在程序中语句p1=p2=p3将不能通过编译。 关于深拷贝和浅拷贝：当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。 4.2 和拷贝构造函数的区别 区别：拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。 #include &amp;lt;iostream&amp;gt; using namespace std; class A { public: A(string str) : name(str) { cout &amp;lt;&amp;lt; &amp;#34;construct &amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; } // 构造函数 A(const A &amp;amp;other) { // 拷贝构造函数 name = &amp;#34;copy &amp;#34; &#43; other." />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://devin0x01.github.io/post/cpp/%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%BA%E6%99%AF/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="调用拷贝构造函数的场景 - DEVIN&#39;s BLOG" />
<meta name="twitter:description"
  content="1.默认构造函数 默认构造函数是一个系统生成的，参数列表和函数体都为空的函数。 如果类中声明了默认构造函数（无论是否有参数），编译器便不再会为之生成隐含的构造函数。
2.析构函数 析构函数的函数列表为空，因此不能实现重载。 可以显式调用析构函数。例如可以通过对象名等进行调用，obj.~A(); 参考文献：显式调用析构函数
3.拷贝构造函数 拷贝构造函数的参数**必须是引用类型。**参数是指针不会编译报错，但是3.1中的场景不能触发调用拷贝构造函数。
3.1 调用拷贝构造函数的3种场景 用一个类的对象去初始化另一个类的对象时 Point a(1, 2); Point b(a); // 调用复制构造函数 Point c = a; // 调用复制构造函数 函数的形参是类对象，当调用函数，进行形参和实参结合时 void fun(Point obj) {} int main() { Point a(1, 2); fun(a); // 调用复制构造函数 } 如果函数的返回值是类对象，当函数执行完成返回调用者时 实际上，由于编译器的优化，可能不会调用。例如：gcc需要指定**-fno-elide-constructors**编译选项才会调用。
Point fun() { Point a(1, 2); return a; // 调用复制构造函数 } b = fun(); 4.赋值运算符 4.1 注意点 **拷贝构造函数必须以引用的方式传递参数，**基本上都是传常量引用的方式传递函数参数。 赋值运算符函数的返回值类型要声明为该类型的引用，并在函数结束前返回实例自身的的引用（this）*。**只有返回一个引用，才能进行连续赋值。否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。假设有3个Person对象：p1、p2、p3，在程序中语句p1=p2=p3将不能通过编译。 关于深拷贝和浅拷贝：当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。 4.2 和拷贝构造函数的区别 区别：拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。 #include &amp;lt;iostream&amp;gt; using namespace std; class A { public: A(string str) : name(str) { cout &amp;lt;&amp;lt; &amp;#34;construct &amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; } // 构造函数 A(const A &amp;amp;other) { // 拷贝构造函数 name = &amp;#34;copy &amp;#34; &#43; other." />
<meta name="twitter:site" content="https://devin0x01.github.io" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://devin0x01.github.io">


<meta property="og:type" content="article" />
<meta property="og:title" content="调用拷贝构造函数的场景 - DEVIN&#39;s BLOG">
<meta property="og:description"
  content="1.默认构造函数 默认构造函数是一个系统生成的，参数列表和函数体都为空的函数。 如果类中声明了默认构造函数（无论是否有参数），编译器便不再会为之生成隐含的构造函数。
2.析构函数 析构函数的函数列表为空，因此不能实现重载。 可以显式调用析构函数。例如可以通过对象名等进行调用，obj.~A(); 参考文献：显式调用析构函数
3.拷贝构造函数 拷贝构造函数的参数**必须是引用类型。**参数是指针不会编译报错，但是3.1中的场景不能触发调用拷贝构造函数。
3.1 调用拷贝构造函数的3种场景 用一个类的对象去初始化另一个类的对象时 Point a(1, 2); Point b(a); // 调用复制构造函数 Point c = a; // 调用复制构造函数 函数的形参是类对象，当调用函数，进行形参和实参结合时 void fun(Point obj) {} int main() { Point a(1, 2); fun(a); // 调用复制构造函数 } 如果函数的返回值是类对象，当函数执行完成返回调用者时 实际上，由于编译器的优化，可能不会调用。例如：gcc需要指定**-fno-elide-constructors**编译选项才会调用。
Point fun() { Point a(1, 2); return a; // 调用复制构造函数 } b = fun(); 4.赋值运算符 4.1 注意点 **拷贝构造函数必须以引用的方式传递参数，**基本上都是传常量引用的方式传递函数参数。 赋值运算符函数的返回值类型要声明为该类型的引用，并在函数结束前返回实例自身的的引用（this）*。**只有返回一个引用，才能进行连续赋值。否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。假设有3个Person对象：p1、p2、p3，在程序中语句p1=p2=p3将不能通过编译。 关于深拷贝和浅拷贝：当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。 4.2 和拷贝构造函数的区别 区别：拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。 #include &amp;lt;iostream&amp;gt; using namespace std; class A { public: A(string str) : name(str) { cout &amp;lt;&amp;lt; &amp;#34;construct &amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; } // 构造函数 A(const A &amp;amp;other) { // 拷贝构造函数 name = &amp;#34;copy &amp;#34; &#43; other." />
<meta property="og:url" content="https://devin0x01.github.io/post/cpp/%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%BA%E6%99%AF/" />
<meta property="og:site_name" content="调用拷贝构造函数的场景" />
<meta property="og:image"
  content="https://devin0x01.github.io">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2023-06-18 14:05:25 &#43;0800 &#43;0800" />










</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://devin0x01.github.io">
        <svg class="octicon" height="32" viewBox="0 0 16 16" version="1.1" width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://devin0x01.github.io">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://devin0x01.github.io">
        <svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" version="1.1"
          width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>
  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://devin0x01.github.io">
                  <img class=" avatar-user"
                    src="https://devin0x01.github.io/images/avatar.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://devin0x01.github.io">DEVIN</a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://devin0x01.github.io/post/cpp/%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%BA%E6%99%AF/">调用拷贝构造函数的场景</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Sun, 18 Jun 2023 14:05:25 &#43;0800"
                    class="no-wrap">
                    Sun, 18 Jun 2023 14:05:25 &#43;0800</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Thu, 11 Jan 2024 08:12:18 &#43;0000"
                    class="no-wrap">
                    Thu, 11 Jan 2024 08:12:18 &#43;0000</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      1067 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/c&#43;&#43;">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      C&#43;&#43;
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="1默认构造函数">1.默认构造函数</h1>
<p><strong>默认构造函数</strong>是一个系统生成的，参数列表和函数体都为空的函数。
如果类中声明了默认构造函数（无论是否有参数），编译器便不再会为之生成隐含的构造函数。</p>
<h1 id="2析构函数">2.析构函数</h1>
<ul>
<li>析构函数的函数列表为空，因此不能实现重载。</li>
<li>可以显式调用析构函数。例如可以通过对象名等进行调用，<code>obj.~A();</code></li>
</ul>
<p><a href="https://www.cnblogs.com/fangyukuan/archive/2010/08/28/1811119.html">参考文献：显式调用析构函数</a></p>
<h1 id="3拷贝构造函数">3.拷贝构造函数</h1>
<blockquote>
<p>拷贝构造函数的参数**必须是引用类型。**参数是指针不会编译报错，但是3.1中的场景不能触发调用拷贝构造函数。</p>
</blockquote>
<h2 id="31-调用拷贝构造函数的3种场景">3.1 调用拷贝构造函数的3种场景</h2>
<ul>
<li>用一个类的对象去初始化另一个类的对象时</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Point</span> <span class="nf">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 调用复制构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Point</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 调用复制构造函数
</span></span></span></code></pre></div><ul>
<li>函数的形参是类对象，当调用函数，进行形参和实参结合时</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="n">Point</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Point</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 调用复制构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>如果函数的返回值是类对象，当函数执行完成返回调用者时</li>
</ul>
<p><strong>实际上，由于编译器的优化，可能不会调用。例如：gcc需要指定</strong><code>**-fno-elide-constructors**</code><strong>编译选项才会调用。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Point</span> <span class="nf">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Point</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 调用复制构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">fun</span><span class="p">();</span>
</span></span></code></pre></div><h1 id="4赋值运算符">4.赋值运算符</h1>
<h2 id="41-注意点">4.1 注意点</h2>
<ul>
<li>**拷贝构造函数必须以引用的方式传递参数，**基本上都是传常量引用的方式传递函数参数。</li>
<li><em><em>赋值运算符函数的返回值类型要声明为该类型的引用，并在函数结束前返回实例自身的的引用（<em>this</em></em>）</em>*。**只有返回一个引用，才能进行连续赋值。否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。假设有3个Person对象：p1、p2、p3，在程序中语句p1=p2=p3将不能通过编译。</li>
<li>关于深拷贝和浅拷贝：当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。</li>
</ul>
<h2 id="42-和拷贝构造函数的区别">4.2 和拷贝构造函数的区别</h2>
<ul>
<li><strong>区别</strong>：拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要<strong>是否有新的对象产生</strong>。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;construct &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">name</span> <span class="o">=</span> <span class="s">&#34;copy &#34;</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 赋值运算符重载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">name</span> <span class="o">=</span> <span class="s">&#34;equal &#34;</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fun1</span><span class="p">(</span><span class="n">A</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="nf">fun2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">obj1</span><span class="p">(</span><span class="s">&#34;obj1&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">obj1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">a</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 下面3行都是调用拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">A</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fun1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-----------&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fun2</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-----------&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 输出：
</span></span></span><span class="line"><span class="cl"><span class="cm">construct acopy a
</span></span></span><span class="line"><span class="cl"><span class="cm">copy a
</span></span></span><span class="line"><span class="cl"><span class="cm">copy a
</span></span></span><span class="line"><span class="cl"><span class="cm">-----------
</span></span></span><span class="line"><span class="cl"><span class="cm">construct obj1
</span></span></span><span class="line"><span class="cl"><span class="cm">copy obj1 (指定-fno-elide-constructors编译选项才有这一项输出)
</span></span></span><span class="line"><span class="cl"><span class="cm">-----------
</span></span></span><span class="line"><span class="cl"><span class="cm">equal a
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></div><h1 id="参考文献">参考文献</h1>
<p><a href="https://www.cnblogs.com/wangguchangqing/p/6141743.html">1. C++ 拷贝构造函数和赋值运算符</a>
<a href="https://blog.csdn.net/huangjw_806/article/details/79134330">2. C++ 拷贝构造函数和赋值运算符函数及其必要性和意义</a>
<a href="https://www.zhihu.com/question/35304261">3. 为什么拷贝构造函数自己的参数必须是引用类型 - 知乎</a></p>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://devin0x01.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://devin0x01.github.io/css/toc.css' />


  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://devin0x01.github.io">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://devin0x01.github.io/js/github-style.js"></script>




</html>