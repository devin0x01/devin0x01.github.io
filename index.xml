<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DEVIN&#39;s BLOG</title>
    <link>https://devin0x01.github.io/</link>
    <description>Recent content on DEVIN&#39;s BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 Aug 2023 16:05:25 +0800</lastBuildDate><atom:link href="https://devin0x01.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>clang-format配置教程</title>
      <link>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/clang-format%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link>
      <pubDate>Tue, 29 Aug 2023 16:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/clang-format%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid>
      <description>配置clang-format Qt Creator使用clang-format_利白的博客-CSDN博客
Git 如何将clang-formatting添加到预提交钩子|极客教程
clang-format二进制文件下载：https://llvm.org/builds
Qt Creator自定义clang-format配置文件位置：C:\Users\&amp;lt;username&amp;gt;\AppData\Roaming\QtProject\qtcreator\beautifier\clangformat
clang-format选项 Clang-Format Style Options — Clang 18.0.0git documentation
.clang-format配置文件是yaml语法格式。
注意：配置文件要保存为UTF-8编码，否则可能会格式化代码失败。
# 语言 Language: Cpp # 基础样式 BasedOnStyle: LLVM # 允许修改头文件顺序 SortIncludes: false # 指针的*的挨着哪边,例如: int* ptr DerivePointerAlignment: true PointerAlignment: Left # 访问修饰符前的空格,例如: public/private AccessModifierOffset: -4 # 缩进宽度 IndentWidth: 4 # 要保留的最大连续空行数 MaxEmptyLinesToKeep: 2 # 大括号{}的换行方式，也可以定义为Custom，然后对if/class等分别设置 BreakBeforeBraces: Linux # 是否允许短方法单行,例如: int f() { return 0; } AllowShortFunctionsOnASingleLine: true # 支持一行的if表达式，例如: if (a) return; AllowShortIfStatementsOnASingleLine: false # 在未封闭(括号的开始和结束不在同一行)的括号中的代码是否对齐,为true,则将参数在左方括号后水平对齐 AlignAfterOpenBracket: true # switch的case缩进 IndentCaseLabels: true # 每行字符的长度 ColumnLimit: 120 # 注释对齐 AlignTrailingComments: true # 括号后加空格,例如: (int) i; SpaceAfterCStyleCast: false # 换行的时候对齐操作符 AlignOperands: true # 中括号两边空格 [] SpacesInSquareBrackets: false # 多行声明语句按照=对齐 AlignConsecutiveDeclarations: false # 容器类的空格 例如: OC的字典 SpacesInContainerLiterals: false # 构造函数初始化列表，冒号后面断行 BreakConstructorInitializers: AfterComma # 函数参数换行 AllowAllParametersOfDeclarationOnNextLine: true # 在续行(#下一行)时的缩进长度 ContinuationIndentWidth: 4 # tab键盘的宽度 TabWidth: 4 # 赋值运算符前加空格 SpaceBeforeAssignmentOperators: true # 行尾的注释前加1个空格 SpacesBeforeTrailingComments: 1 </description>
    </item>
    
    <item>
      <title>nvim配置教程</title>
      <link>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/nvim%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link>
      <pubDate>Wed, 16 Aug 2023 16:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/nvim%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid>
      <description>1.安装NerdFont字体 ryanoasis/nerd-fonts: Iconic font aggregator
How do I install fonts? - Ask Ubuntu
bash - MobaXTerm Powerline Font Issue - Super User
没有root权限时，ttf文件放在~/.fonts或者~/.local/share/fonts目录下
有root权限时，放在/usr/local/share/fonts目录下
# 安装字体 fc-cache -fv fc-list | grep &amp;lt;name-of-font&amp;gt; 2.掘金小册配置 2.1.目录结构 首先 init.lua 是整个配置的入口文件，负责引用所有其他的模块，基本上想要打开或关闭某个插件只要在这里修改一行代码即可。
basic.lua： 基础配置，是对默认配置的一个重置。
colorscheme.lua： 我们安装的主题皮肤配置，在这里切换主题。
keybindings.lua： 快捷键的设置，所有插件的快捷键也都会放在这里。
plugins.lua： 插件安装管理，插件安装或卸载全在这里设置。
lsp 文件夹： 是对 Neovim 内置 LSP 功能的配置，包括常见编程语言与语法提示等。
config ： 文件夹包含各种语言服务器单独的配置文件。
setup.lua ： 内置 LSP 的配置。
cmp.lua ： 语法自动补全补全的配置，包括各种补全源，与自定义代码段。
ui.lua： 对内置 LSP 功能增强和 UI 美化。
formatter.lua： 独立代码格式化功能。</description>
    </item>
    
    <item>
      <title>指向成员函数的指针</title>
      <link>https://devin0x01.github.io/post/cpp/%E6%8C%87%E5%90%91%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 15 Aug 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/%E6%8C%87%E5%90%91%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88/</guid>
      <description>c++ - How do I typedef a function pointer with the C++11 using syntax? - Stack Overflow
#include &amp;lt;iostream&amp;gt; class A { public: void display() { std::cout &amp;lt;&amp;lt; &amp;#34;A display&amp;#34; &amp;lt;&amp;lt; std::endl; } }; int main() { typedef void (A::*PF1)(); PF1 pf1 = &amp;amp;A::display; A a1; (a1.*pf1)(); using PF2 = void (A::*)(); PF2 pf2 = &amp;amp;A::display; A* a2 = new A; (a2-&amp;gt;*pf2)(); return 0; } // output: // A display // A display </description>
    </item>
    
    <item>
      <title>operator bool 函数</title>
      <link>https://devin0x01.github.io/post/cpp/operator-bool-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 14 Aug 2023 16:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/operator-bool-%E5%87%BD%E6%95%B0/</guid>
      <description>参考文档 user-defined conversion function - cppreference.com
The Safe Bool Idiom - 知乎
为什么operator bool()需要用explicit修饰? c++ - Why does declaring an operator bool() const member overload the [] operator? - Stack Overflow
The operator is coming from the built-in subscript operator which treats expressions A[B] as *(A + B).
This results in the evaluation of *(1 + &amp;quot;wut&amp;quot;) =&amp;gt; &#39;u&#39;, which then causes the if condition to pass, as &#39;u&#39; is a non-zero value.</description>
    </item>
    
    <item>
      <title>自建RSS服务</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/%E8%87%AA%E5%BB%BArss%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 08 Aug 2023 16:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/%E8%87%AA%E5%BB%BArss%E6%9C%8D%E5%8A%A1/</guid>
      <description>我的 RSS 最佳实践
1.部署Fresh RSS 笔记｜Docker 快速搭建 FreshRSS | Jack‘s Space
Docker 时区调整方案-腾讯云开发者社区-腾讯云
Android可以使用Feedme客户端，Windows可以通过ip:port方式访问
docker run -d --restart unless-stopped --log-opt max-size=10m \ -p 8282:80 \ -e TZ=Asia/Shanghai \ -e &amp;#39;CRON_MIN=1,15,31&amp;#39; \ -v /opt/freshrss/data:/var/www/FreshRSS/data \ -v /opt/freshrss/extensions:/var/www/FreshRSS/extensions \ --name freshrss \ freshrss/freshrss 2.部署Tiny Tiny RSS docker-compose 部署 RSS 服务订阅、安装tiny-tiny-rss、RSSHub - 贝尔塔猫 - 博客园
# 下载 docker-compose.yml 配置文件 mkdir -p /opt/ttrss &amp;amp;&amp;amp; cd /opt/ttrss curl -fLo docker-compose.yml https://raw.githubusercontent.com/HenryQW/Awesome-TTRSS/main/docker-compose.yml # 删除 Docker 容器 docker-compose down # 删除已停止的 Docker 容器 docker-compose rm # 开启 Docker 服务 docker-compose up -d 默认账户：admin/password</description>
    </item>
    
    <item>
      <title>frp内网穿透配置教程</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 04 Aug 2023 16:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid>
      <description>重要资料 fatedier/frp - github
官方文档 | frp
司波图/自建内网穿透服务器 - 码云
$ tree /opt/frp /opt/frp ├── frpc ├── frpc_full.ini ├── frpc.ini ├── frps ├── frps_full.ini ├── frps.ini └── LICENSE 1.SSH访问内网机器 通过 SSH 访问内网机器 | frp
1.1.Server配置 在具有公网 IP 的机器上部署 frps，修改 frps.ini 文件，这里使用了最简化的配置，设置了 frp 服务器用户接收客户端连接的端口。
#/opt/frp/frps.ini [common] bind_port = 7000 # 注意：需要在云服务设置开放7000端口 # 身份验证(可选) token = i*RY2KI9^A7H # web界面 dashboard_port = 7500 # dashboard 用户名密码，可选，默认为空 dashboard_user = admin dashboard_pwd = admin 运行方式：/opt/frp/frps -c /opt/frp/frps.</description>
    </item>
    
    <item>
      <title>Photoshop按比例裁剪压缩图片</title>
      <link>https://devin0x01.github.io/post/%E5%8A%9E%E5%85%AC/photoshop%E6%8C%89%E6%AF%94%E4%BE%8B%E8%A3%81%E5%89%AA%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</link>
      <pubDate>Thu, 03 Aug 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E5%8A%9E%E5%85%AC/photoshop%E6%8C%89%E6%AF%94%E4%BE%8B%E8%A3%81%E5%89%AA%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</guid>
      <description>1.选择侧边栏的裁剪工具，然后修改裁剪比例，点击对号
2.点击 文件/存储为 菜单会跳出下面的对话框，可以修改图片的大小</description>
    </item>
    
    <item>
      <title>Systemd教程</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/systemd%E6%95%99%E7%A8%8B/</link>
      <pubDate>Mon, 31 Jul 2023 16:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/systemd%E6%95%99%E7%A8%8B/</guid>
      <description>Systemd 入门教程：实战篇 - 阮一峰的网络日志
配置文件 $ systemctl cat sshd.service [Unit] Description=OpenSSH server daemon Documentation=man:sshd(8) man:sshd_config(5) After=network.target sshd-keygen.service Wants=sshd-keygen.service [Service] EnvironmentFile=/etc/sysconfig/sshd ExecStart=/usr/sbin/sshd -D $OPTIONS ExecReload=/bin/kill -HUP $MAINPID Type=simple KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target Unit区块：启动顺序和依赖关系 Description字段给出当前服务的简单描述。
Documentation字段给出文档位置。
After字段表示如果network.target或sshd-keygen.service需要启动，那么sshd.service应该在它们之后启动。
Before字段定义sshd.service应该在哪些服务之前启动。
Wants字段表示sshd.service与sshd-keygen.service之间存在&amp;quot;弱依赖&amp;quot;关系，即如果sshd-keygen.service启动失败或停止运行，不影响sshd.service继续执行。
Requires字段则表示&amp;quot;强依赖&amp;quot;关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。
注意，After和Before字段只涉及启动顺序，不涉及依赖关系。
注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。
举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。
Service区块：如何启动当前服务 EnvironmentFile字段指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。上面的例子中，sshd 的环境参数文件是/etc/sysconfig/sshd。
ExecStart字段：定义启动进程时执行的命令。上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。
Install区块：如何安装这个配置文件，即怎样做到开机启动。 WantedBy字段：表示该服务所在的Target。Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd所在的Target是multi-user.target。 这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在/etc/systemd/system目录下面的multi-user.target.wants子目录之中。
Systemd 有默认的启动 Target，下面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。</description>
    </item>
    
    <item>
      <title>Docker常用命令</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 31 Jul 2023 12:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Docker — 从入门到实践
Docker Guide
清理Docker的container，image与volume · 零壹軒·笔记
docker docker info #docker配置信息 docker inspect $cid #查看容器的配置信息 docker images docker ps -a docker run -it $image_id --rm #rm表示退出容器后就删除该容器 docker exec -it $cid /bin/bash docker start $cid docker stop $cid docker restart $cid docker rm -f $cid docker rm -v $cid #同时删除 /var/lib/docker 目录下的数据卷 docker logs $cid #查看容器日志 docker system df #查看docker缓存大小 docker system prune docker builder prune #一键清理 Build Cache docker builder prune --filter &amp;#39;until=240h&amp;#39; #保留最近10天的缓存 docker tag ca1b6b825289 devincpp/rk3568:v1.</description>
    </item>
    
    <item>
      <title>WireGuard配置教程.md</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/wireguard%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sun, 30 Jul 2023 12:10:05 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/wireguard%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid>
      <description>Run WireGuard VPN Server in Docker Container with Docker Compose - TechViewLeo &amp;ndash; 主要参考这个
基于Wireguard技术的虚拟个人网络搭建: 基于wireguard的内网穿透技术~
搭建WireGuard-腾讯云开发者社区-腾讯云
公网机器: IP=100.101.102.103, Name=TencentVM1 私网机器: IP=192.168.123.189, Name=LocalMint1 1.服务端配置 1.1.安装wg-easy镜像 wg-easy/wg-easy: The easiest way to run WireGuard VPN + Web-based Admin UI.
基于Wireguard技术的虚拟个人网络搭建: 基于wireguard的内网穿透技术~
Wireguard 全互联模式（full mesh）配置指南 – 云原生实验室 - Kubernetes|Docker|Istio|Envoy|Hugo|Golang|云原生
这个新建的容器内会多一个wg0网卡，IP地址是10.0.8.1，而且网卡只在容器内可见。
server的配置文件会放在/opt/wg-easy目录下。TCP的51821端口用于访问WebUI。
docker run -d \ --name=wg-easy \ -e WG_HOST=123.123.123.123 (🚨这里输入服务器的公网IP) \ -e PASSWORD=passwd123 (🚨这里输入你的密码) \ -e WG_DEFAULT_ADDRESS=10.0.8.x （🚨默认IP地址）\ -e WG_DEFAULT_DNS=114.114.114.114 （🚨默认DNS）\ -e WG_ALLOWED_IPS=10.0.8.0/24 （🚨允许连接的IP段）\ -e WG_PERSISTENT_KEEPALIVE=25 （🚨重连间隔）\ -v /opt/wg-easy:/etc/wireguard \ -p 51820:51820/udp \ -p 51821:51821/tcp \ --cap-add=NET_ADMIN \ --cap-add=SYS_MODULE \ --sysctl=&amp;#34;net.</description>
    </item>
    
    <item>
      <title>Docker内显示图形界面</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/docker%E5%86%85%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</link>
      <pubDate>Fri, 28 Jul 2023 16:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/docker%E5%86%85%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</guid>
      <description>关于X11 x(7) - Linux man page
Cygwin系列（十二）：了解X - 知乎
X11采用了C/S的架构，在其设计下，整个图形视窗系统主要分为3个部分：
1.X Server（X服务器）。X Server一方面负责和设备驱动交互，监听显示器和键盘鼠标，另一方面响应X Client需求传递键盘、鼠标事件、（通过设备驱动）绘制图形文字等。反直觉之一，X Server运行在本地。
2.X Client（X客户端）。X Client也叫X应用程序，负责实现程序逻辑，在收到设备事件后计算出绘图数据，由于本身没有绘制能力，只能向X Server发送绘制请求和绘图数据，告诉X Server在哪里绘制一个什么样的图形。X Client可以和X Server在同一个主机上，也可以通过TCP/IP网络连接。
3.Window Manager（窗口管理器，简称WM），或者叫合成器（Compositor）。多个X Client向X Server发送绘制请求时，各X Client程序并不知道彼此的存在，绘制图形出现重叠、颜色干扰等问题是大概率事件，这就需要一个管理者统一协调，即Window Manager，它掌管各X Client的Window（窗口）视觉外观，如形状、排列、移动、重叠渲染等。反直觉之二，Window Manager并非X Server的一部分，而是一个特殊的X Client程序。
3个部分， X Server是整个X Window System的中心，协调X客户端和窗口管理器的通信。
常用命令 xorg - What does $DISPLAY environment variable mean - Ask Ubuntu
x11 forwarding - How to fix &amp;ldquo;MobaXterm X11 proxy: Unsupported authorisation protocol&amp;rdquo; - Super User
echo $DISPLAY # 注意：`xauth add` 之后可能需要重新连接才能生效!! xauth add $DISPLAY .</description>
    </item>
    
    <item>
      <title>CMake语法基础</title>
      <link>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/cmake%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 26 Jul 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/cmake%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</guid>
      <description>基本表达式 if — CMake 3.27.1 Documentation
Cmake中的条件判断if/elseif/else - 简书
if(&amp;lt;constant&amp;gt;) True if the constant is 1, ON, YES, TRUE, Y, or a non-zero number (including floating point numbers). False if the constant is 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND, the empty string, or ends in the suffix -NOTFOUND. Named boolean constants are case-insensitive. If the argument is not one of these specific constants, it is treated as a variable or string (see Variable Expansion further below) and one of the following two forms applies.</description>
    </item>
    
    <item>
      <title>target_link_libraries中的PRIVATE INTERFACE PUBLIC.md</title>
      <link>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/target_link_libraries%E4%B8%AD%E7%9A%84private-interface-public/</link>
      <pubDate>Mon, 24 Jul 2023 18:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/target_link_libraries%E4%B8%AD%E7%9A%84private-interface-public/</guid>
      <description>CMake target_link_libraries Interface Dependencies - Stack Overflow CMake的链接选项：PRIVATE，INTERFACE，PUBLIC - 知乎
If you are creating a shared library and your source cpp files #include the headers of another library (Say, QtNetwork for example), but your header files don&amp;rsquo;t include QtNetwork headers, then QtNetwork is a PRIVATE dependency.
If your source files and your headers include the headers of another library, then it is a PUBLIC dependency.
If your header files other than your source files include the headers of another library, then it is an INTERFACE dependency.</description>
    </item>
    
    <item>
      <title>调用成员模板</title>
      <link>https://devin0x01.github.io/post/cpp/%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Thu, 20 Jul 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF/</guid>
      <description>C++访问成员模板需要加template关键字
#include &amp;lt;iostream&amp;gt; using namespace std; class A { public: template &amp;lt;typename TypeNum&amp;gt; int getSize() { return sizeof(TypeNum); } }; // 调用成员模板函数需要加template template &amp;lt;typename T&amp;gt; void f1() { T t1; cout &amp;lt;&amp;lt; (t1.template getSize&amp;lt;float&amp;gt;()) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; (t1.template getSize&amp;lt;double&amp;gt;()) &amp;lt;&amp;lt; endl; } // 调用成员模板函数不需要加template void f2() { A a1; cout &amp;lt;&amp;lt; (a1.getSize&amp;lt;long&amp;gt;()) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; (a1.getSize&amp;lt;long long&amp;gt;()) &amp;lt;&amp;lt; endl; } int main() { f1&amp;lt;A&amp;gt;(); f2(); return 0; } </description>
    </item>
    
    <item>
      <title>vector的push_back与emplace_back.md</title>
      <link>https://devin0x01.github.io/post/cpp/vector%E7%9A%84push_back%E4%B8%8Eemplace_back/</link>
      <pubDate>Mon, 17 Jul 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/vector%E7%9A%84push_back%E4%B8%8Eemplace_back/</guid>
      <description>push_back与emplace_back #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; class A { public: A() = default; A(string name) : _name(name) { cout &amp;lt;&amp;lt; &amp;#34;ctor: &amp;#34; &amp;lt;&amp;lt; _name &amp;lt;&amp;lt; endl; } ~A() { cout &amp;lt;&amp;lt; &amp;#34;dtor: &amp;#34; &amp;lt;&amp;lt; _name &amp;lt;&amp;lt; endl; } // 拷贝构造函数 A(const A &amp;amp;other) { _name += &amp;#34;cp-&amp;#34; + other._name; cout &amp;lt;&amp;lt; &amp;#34;cp-ctor: &amp;#34; &amp;lt;&amp;lt; _name &amp;lt;&amp;lt; endl; } // 赋值运算符 A&amp;amp; operator=(const A &amp;amp;other) { if (this != &amp;amp;other) { _name += &amp;#34;cp-&amp;#34; + other.</description>
    </item>
    
    <item>
      <title>位域用法</title>
      <link>https://devin0x01.github.io/post/cpp/%E4%BD%8D%E5%9F%9F%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 13 Jul 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/%E4%BD%8D%E5%9F%9F%E7%94%A8%E6%B3%95/</guid>
      <description>[toc]
如果有字段定义为int类型的话，那么符号位的判断需要特别注意。 例如：下面的 B::f2 字段是有符号类型，其符号位是f2的最高位，可以表示的范围是-64~63
#include &amp;lt;iostream&amp;gt; struct B { unsigned int f1:1; int f2:7; }; int main() { B b1 = {0, 10}; B b2 = {0, 127}; std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; (b1.f2 &amp;gt;= 0) &amp;lt;&amp;lt; std::endl; // true std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; (b2.f2 &amp;gt;= 0) &amp;lt;&amp;lt; std::endl; // false } #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; struct Flags { uint32_t k1 : 1; }; struct AA { // Flags flag : 1; // error: bit-field ‘flag’ with non-integral type ‘Flags’ Flags flag; bool a1 : 1; uint32_t a2 : 4; }; int main() { cout &amp;lt;&amp;lt; sizeof (AA) &amp;lt;&amp;lt; endl; AA obj; memset(&amp;amp;obj, 0, sizeof(AA)); obj.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17特性</title>
      <link>https://devin0x01.github.io/post/cpp/c&#43;&#43;17%E7%89%B9%E6%80%A7/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/c&#43;&#43;17%E7%89%B9%E6%80%A7/</guid>
      <description>构造函数模板推导 在C++17前构造一个模板类对象需要指明类型：
pair&amp;lt;int, double&amp;gt; p(1, 2.2); // before c++17 C++17就不需要特殊指定，直接可以推导出类型，代码如下：
pair p(1, 2.2); // c++17 自动推导 vector v = {1, 2, 3}; // c++17 结构化绑定 1.获取值 // 绑定tuple std::tuple&amp;lt;int, double&amp;gt; func() { return std::tuple(1, 2.2); } int main() { auto[i, d] = func(); cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl; } // 绑定map void f() { map&amp;lt;int, string&amp;gt; m = {{0, &amp;#34;a&amp;#34;}, {1, &amp;#34;b&amp;#34;}}; for (const auto &amp;amp;[i, s] : m) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; } } // 绑定pair int main() { std::pair a(1, 2.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;练习题</title>
      <link>https://devin0x01.github.io/post/cpp/c&#43;&#43;%E7%BB%83%E4%B9%A0%E9%A2%98/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/c&#43;&#43;%E7%BB%83%E4%B9%A0%E9%A2%98/</guid>
      <description>多态 判断 Q1: 虚函数可以是内联的？ A1: 错误。内联是编译时刻决定的，虚函数是运行时刻动态决定的，所以虚函数不能是内联函数。虚函数前加上inline不会报错，但是会被忽略。
Q2: 一个类内部，可以同时声明 static void fun() 和 virutal void fun() 两个函数？ A2: 错误。虽然静态函数不存在this指针，但是还是不能声明同参的虚函数和静态函数。
Q3: 基类的析构函数非虚，派生类的析构函数是虚函数。delete派生类指针(指向派生类对象)会调用基类析构函数？ A3: 正确。
通过派生类指针，删除派生类对象时，无论父类析构函数是不是虚函数，都会调用基类析构函数。
通过基类指针，删除派生类对象时，是否调用基类析构函数，取决于基类析构函数是否是virtual函数
知识点 可以通过对象名主动调用析构函数，主动调用构造函数会出错。
如果类中声明了构造函数（无论是否有参数），编译器便不会再为之生成隐含的构造函数。
构造函数不能是虚函数，析构函数可以是虚函数。
编程 析构函数需要声明为virtual #include &amp;lt;iostream&amp;gt; using namespace std; int g_num = 0; class Base { public: Base() {} ~Base() { g_num += 1; } }; class Derived:public Base { public: Derived() {} ~Derived() { g_num += 2; } }; int main() { Base *p = new Derived(); delete p; cout &amp;lt;&amp;lt; g_num &amp;lt;&amp;lt; endl; return 0; } // 输出：1 动态绑定依赖于指针或者引用 #include &amp;lt;iostream&amp;gt; using namespace std; class Base { public: virtual void fun() {cout &amp;lt;&amp;lt; &amp;#34;base&amp;#34; &amp;lt;&amp;lt; endl;} }; class Derived:public Base { public: virtual void fun() { cout &amp;lt;&amp;lt; &amp;#34;derived&amp;#34; &amp;lt;&amp;lt; endl;} }; void func1(Base &amp;amp;obj) { obj.</description>
    </item>
    
    <item>
      <title>cgdb配置</title>
      <link>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/cgdb%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/cgdb%E9%85%8D%E7%BD%AE/</guid>
      <description>1.安装 git clone git://github.com/cgdb/cgdb.git cd cgdb ./autogen.sh ./configure --prefix=/usr/local make sudo make install # 报错解决方法 sudo apt-get install automake libncurses5-dev flex texinfo libreadline-dev 2.配置 vim ~/.cgdb/cgdbrc set ignorecaseset ts=4 set wso=vertical set eld=shortarrow set hls map &amp;lt;F9&amp;gt; :until&amp;lt;cr&amp;gt; 3.快捷键 F5 - Send a run command to GDB. F6 - Send a continue command to GDB. F7 - Send a finish command to GDB. F8 - Send a next command to GDB.</description>
    </item>
    
    <item>
      <title>coredump配置</title>
      <link>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/coreddump%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/coreddump%E9%85%8D%E7%BD%AE/</guid>
      <description>ulimit -c unlimited echo &amp;#34;1&amp;#34; &amp;gt; /proc/sys/kernel/core_uses_pid mkdir -p /opt/debug echo &amp;#34;/opt/debug/core-%e-%p-%t&amp;#34; &amp;gt; /proc/sys/kernel/core_pattern gdb &amp;lt;program&amp;gt; -c &amp;lt;coredump_file&amp;gt; up &amp;lt;n&amp;gt; #调用栈向上n次 </description>
    </item>
    
    <item>
      <title>expect实现交互式输入</title>
      <link>https://devin0x01.github.io/post/shell/expect%E5%AE%9E%E7%8E%B0%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%BE%93%E5%85%A5/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/shell/expect%E5%AE%9E%E7%8E%B0%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%BE%93%E5%85%A5/</guid>
      <description>1.常用命令 选项： -c:执行脚本前先执行的命令，可多次使用。 -d:debug模式，可以在运行时输出一些诊断信息，与在脚本开始处使用exp_internal 1相似。 -D:启用交换调式器,可设一整数参数。 -f:从文件读取命令，仅用于使用#!时。如果文件名为&amp;quot;-&amp;quot;，则从stdin读取(使用&amp;quot;./-&amp;ldquo;从文件名为-的文件读取)。 -i:交互式输入命令，使用&amp;quot;exit&amp;quot;或&amp;quot;EOF&amp;quot;退出输入状态。 &amp;ndash;:标示选项结束(如果你需要传递与expect选项相似的参数给脚本时)，可放到#!行:#!/usr/bin/expect &amp;ndash;。 -v:显示expect版本信息。
# 命令行参数 # $argv，参数数组，使用[lindex $argv n]获取，$argv 0为脚本名字 # $argc，参数个数 set username [lindex $argv 1] # 获取第1个参数 set passwd [lindex $argv 2] # 获取第2个参数 set timeout 30 # 设置超时 # spawn是expect内部命令，开启ssh连接 spawn ssh -l username 192.168.1.1 # 判断上次输出结果里是否包含“password:”的字符串，如果有则立即返回，否则就等待一段时间(timeout)后返回 expect &amp;#34;password:&amp;#34; # 发送内容ispass(密码、命令等) send &amp;#34;ispass\r&amp;#34; # 发送内容给用户 send_user &amp;#34;$argv0 [lrange $argv 0 2]\n&amp;#34; send_user &amp;#34;It&amp;#39;s OK\r&amp;#34; # 执行完成后保持交互状态，控制权交给控制台(手工操作)。否则会完成后会退出。 interact 2.例子 2.1自动telnet会话 #!</description>
    </item>
    
    <item>
      <title>Git常用命令</title>
      <link>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>1.git remote 关联远端仓库 git remote add origin git@github.com:git_username/repository_name.git git remote remove origin git remote -v 2.git branch 本地分支关联远程分支(目的是在执行git pull/push操作时就不需要指定对应的远程分支) git branch --set-upstream-to=origin/master git branch -u origin/master 切换分支 git checkout -b &amp;lt;new_branch&amp;gt; 查看所有分支 git branch -a 更改分支名称 git branch -m br_old br_new 3.git push 删除远程分支 git push origin --delete &amp;lt;branch&amp;gt; 同步到远程分支 git push -u origin &amp;lt;local_branch&amp;gt;:&amp;lt;remote_branch&amp;gt; 4.git diff 查看当前没有add的内容修改 git diff 查看已经add没有commit的改动 git diff --cached 查看当前没有add和commit的改动 git diff HEAD 或者 git status 再查看任意连个版本之间的改动 git diff &amp;lt;版本号码1&amp;gt; &amp;lt;版本号码2&amp;gt; 比较两个版本号src文件夹的差异 git diff &amp;lt;版本号码1&amp;gt; &amp;lt;版本号码2&amp;gt; src 5.</description>
    </item>
    
    <item>
      <title>Java基础</title>
      <link>https://devin0x01.github.io/post/java/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/java/java%E5%9F%BA%E7%A1%80/</guid>
      <description>数据类型 INFINITY和NaN // INFINITY定义 public static final double POSITIVE_INFINITY = 1.0 / 0.0; public static final double NEGATIVE_INFINITY = -1.0 / 0.0; public static final float POSITIVE_INFINITY = 1.0f / 0.0f; public static final float NEGATIVE_INFINITY = -1.0f / 0.0f; // 无穷大*0=NAN System.out.println(Float.POSITIVE_INFINITY * 0); // output: NAN // 无穷大 System.out.println((Float.POSITIVE_INFINITY / 0) == Float.POSITIVE_INFINITY); // output: true System.out.println(Float.POSITIVE_INFINITY == (Float.POSITIVE_INFINITY + 10000)); // output: true System.out.println(Float.POSITIVE_INFINITY == (Float.POSITIVE_INFINITY / 10000)); // output: true // 判断是否为INFINITY System.</description>
    </item>
    
    <item>
      <title>Linux网络编程</title>
      <link>https://devin0x01.github.io/post/linux%E5%BC%80%E5%8F%91/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/linux%E5%BC%80%E5%8F%91/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>查看端口占用情况 netstat -tunlp
-t (tcp) 仅显示tcp相关选项 -u (udp) 仅显示udp相关选项
-n 拒绝显示列名，能显示数字的全部转化为数字
-l 仅显示出在listen(监听）的服务状态
-p 显示潜力相关链接的程序名
linux查看端口被哪个进程占用的方法
本机地址 127.0.0.1: 这个地址通常分配给loopback接口，loopback是一个特殊的网络IP，可以理解为虚拟网卡，用于本机中各个应用之间的网络交互，只要操作系统网络组建正常，loopback就能工作。所以这里需要明白使用127.0.0.1进行通信时，必须要保证client和server在同一台机器上。
INADDR_ANY: 从字面上的any可以看出，转换过来其实是0.0.0.0，泛指本机的意思，也就是标识本机的所有IP，因为有些机器是不止一块网卡的，在多网卡的情况下，这个就表示所有的网卡IP地址的意思，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
如果现在有两台PC在同一个局域网内，分别为PC1与PC2，PC1上有一个网卡，IP地址为192.168.10.128
PC1中sever监听127.0.0.1，则PC1中的client可以连上127.0.0.1，192.168.10.128连不上；而PC2中client都连不上。 PC1中sever监听192.168.10.128，则PC1中的client可以连上192.168.10.128，127.0.0.1连不上；而PC2中client能连上192.168.10.128。 PC1中sever监听0.0.0.0，则PC1中的client可以连上127.0.0.1和192.168.10.128，PC2中的client能连上192.168.10.128。 socket基础接口 close关闭socket 调用close函数，会向连接的对应套接字发送EOF (ch04/echo_server.c)
文件结束符：如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
终端特殊字符：EOF 是传统模式下的文件结尾字符（通常是 Ctrl-D）。在一行的开始处输入这个字符会导致在终端上读取输入的进程检测到文件结尾的情况（即，read()返回 0）。如果不在一行的开始处，而在其他地方输入这个字符，那么该字符会立刻导致 read()完成调用，返回这一行中目前为止读取到的字符数。在这两种情况下，EOF 字符本身都不会传递给读取的进程。
shutdown优雅的断开TCP连接 /* Shut down all or part of the connection open on socket FD. HOW determines what to shut down: SHUT_RD = No more receptions; SHUT_WR = No more transmissions; SHUT_RDWR = No more receptions or transmissions.</description>
    </item>
    
    <item>
      <title>Notepad&#43;&#43;替换</title>
      <link>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/notepad&#43;&#43;%E6%9B%BF%E6%8D%A2/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/notepad&#43;&#43;%E6%9B%BF%E6%8D%A2/</guid>
      <description>\1表示匹配的第一组括号</description>
    </item>
    
    <item>
      <title>Qt开发总结篇一</title>
      <link>https://devin0x01.github.io/post/qt/qt%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E7%AF%87%E4%B8%80/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/qt/qt%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E7%AF%87%E4%B8%80/</guid>
      <description>GUI界面 限制输入的内容 QValidator *validator = new QIntValidator(100, 999, this); // 这样文本框只能输入100~999之间的数字 ui-&amp;gt;lineEdit-&amp;gt;setValidator(validator); 显示格式控制 ui-&amp;gt;textEdit-&amp;gt;setWordWrapMode(QTextOption::WrapAnywhere); // 任意地方换行 ui-&amp;gt;tableWidget-&amp;gt;setTextElideMode(Qt::ElideMode); // 不显示省略号 Qt序列化 通过全局流操作运算符重载实现，可以序列化到文件等设备中，也可以序列化到QByteArray中。
// cmdinfo.h // BaseInfo已经实现序列化 class CmdInfo : public BaseInfo { public: friend QDataStream&amp;amp; operator&amp;gt;&amp;gt;(QDataStream&amp;amp;, CmdInfo&amp;amp;); friend QDataStream&amp;amp; operator&amp;lt;&amp;lt;(QDataStream&amp;amp;, const CmdInfo&amp;amp;); private: QString command_; CmdType type_; }; // cmdinfo.cpp QDataStream&amp;amp; operator&amp;gt;&amp;gt;(QDataStream &amp;amp;in, CmdInfo &amp;amp;data) { BaseInfo &amp;amp;base = data; qint32 tmpInt; in &amp;gt;&amp;gt; base &amp;gt;&amp;gt; data.command_ &amp;gt;&amp;gt; tmpInt; data.setType((CmdType)tmpInt); return in; } QDataStream&amp;amp; operator&amp;lt;&amp;lt;(QDataStream &amp;amp;out, const CmdInfo &amp;amp;data) { const BaseInfo &amp;amp;base = data; out &amp;lt;&amp;lt; base &amp;lt;&amp;lt; data.</description>
    </item>
    
    <item>
      <title>Terminal快捷键</title>
      <link>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/terminal%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/terminal%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>命令行快速移动光标 Ctrl+A/E 行首/行末 Alt+F/B 按单词前后移动 Alt . 上条命令行的最后一个参数 Ctrl+W/K 删除光标前后的内容</description>
    </item>
    
    <item>
      <title>共享库搜索路径</title>
      <link>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/%E5%85%B1%E4%BA%AB%E5%BA%93%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/%E5%85%B1%E4%BA%AB%E5%BA%93%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/</guid>
      <description>基本原理 -L编译选项是编译期间使用
LD_LIBRARY_PATH环境变量是运行期间使用，可以用来指定so的加载路径，并且优先级高于系统默认的。
RPATH和RUNPATH是ELF格式里面的一个数据，rpath编译选项实际上是在可执行文件中加入了RUNPATH或者RPATH。
小结一下一个ELF文件自身加载so的情况(不可信，仅供参考）：
其实这三者的关系概括起来没有几点：
LD_LIBRARY_PATH是个环境变量，优先级高于系统默认的。 RPATH是ELF格式里面的一个数据，他的优先级比LD_LIBRARY_PATH还要高 RUNPATH很特殊，如果他出现了RPATH就躲起来了，LD_LIBRARY_PATH 又成了首选?? ELF 中 RPATH ELF 中 RUNPATH LD_LIBRARY_PATH 变量 尝试加载目录的顺序 未设置 未设置 未设置 /lib =&amp;gt; /usr/lib 未设置 未设置 设置 ${LD_LIBRARY_PATH} =&amp;gt; /lib =&amp;gt; /usr/lib 设置 未设置 未设置 ${RPATH} =&amp;gt; /lib =&amp;gt; /usr/lib 设置 未设置 设置 ${RPATH} =&amp;gt; ${LD_LIBRARY_PATH} =&amp;gt; /lib =&amp;gt; /usr/lib 设置 或 未设置 设置 设置 ${LD_LIBRARY_PATH} =&amp;gt; ${RUN_PATH} =&amp;gt; /lib =&amp;gt; /usr/lib 设置 或 未设置 设置 未设置 ${RUN_PATH} =&amp;gt; /lib =&amp;gt; /usr/lib LD_LIBRARY_PATH 例子 // a.</description>
    </item>
    
    <item>
      <title>函数重载及其匹配顺序</title>
      <link>https://devin0x01.github.io/post/cpp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%85%B6%E5%8C%B9%E9%85%8D%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%85%B6%E5%8C%B9%E9%85%8D%E9%A1%BA%E5%BA%8F/</guid>
      <description>1.函数重载 概念：同一个作用域内，同名函数，参数列表不同(参数个数、类型或顺序不同)。
与返回值类型没有关系。如果函数名和参数列表相同，无论返回值类型是否相同，会编译错误（函数重定义） const是有效的重载。 仅默认参数值不同不是有效的重载。例如 int fun(int a = 0); // void fun(int a = 1); // error: functions that differ only in their return type cannot be overloaded virutal是无效的重载。virtual关键字可有可无，不影响是否是重载函数。 2.函数重载匹配顺序 编译器根据最佳匹配确定调用哪个函数。C++ 编译器遵循以下先后顺序：
先找参数完全匹配的普通函数（非由模板实例化得到的函数）。 再找参数完全匹配的模板函数。 再找实参经过自动类型转换后能够匹配的普通函数。 如果上面的都找不到，则报错。 template &amp;lt;class T&amp;gt; void fun(T x, T y) { cout &amp;lt;&amp;lt; &amp;#34;fun1&amp;#34; &amp;lt;&amp;lt; endl; } template &amp;lt;class T1, class T2&amp;gt; void fun(T1 x, T2 y) { cout &amp;lt;&amp;lt; &amp;#34;fun2&amp;#34; &amp;lt;&amp;lt; endl; } void fun(int x, int y, int z = 0) { cout &amp;lt;&amp;lt; &amp;#34;fun3&amp;#34; &amp;lt;&amp;lt; endl; } void fun(char x, char y) { cout &amp;lt;&amp;lt; &amp;#34;fun4&amp;#34; &amp;lt;&amp;lt; endl; } int main() { int i1=2, i2=3, i3=5; char c1=&amp;#39;a&amp;#39;, c2=&amp;#39;c&amp;#39;, c3=&amp;#39;d&amp;#39;; double f1=2.</description>
    </item>
    
    <item>
      <title>字符集与编码</title>
      <link>https://devin0x01.github.io/post/java/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/java/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81/</guid>
      <description>术语 字符(character)是具有语义值的文本的最小单位。 字符集(character set)是可能由多种语言使用的字符的集合。例：拉丁语字符集由英语和大多数欧洲语言使用，但希腊语字符集仅由希腊语使用。 编码字符集(coded character set)是一个字符集，其中每个字符对应于一个唯一的数字。 一个编码字符集的编码点(code point)是字符集中或编码空间中允许的任何值。 编码空间(code space)是一个整数范围，其值为编码点。 编码单元(code unit)是一个位序列，用于在给定的编码表单中对库的每个字符进行编码。有的文档中称之为编码值(code value)。
编码单元例子：US-ASCII: 7 bits，UTF-8, GB18030: 8 bits，UTF-16: 16 bits，UTF-32: 32 bits
字符串&amp;quot;abc𐐀&amp;quot; 包括4个字符，4个编码点： (1) UTF-32编码时: 4个编码单元，00000061, 00000062, 00000063, 00010400 (2) UTF-16编码时: 5个编码单元，0061, 0062, 0063, d801, dc00 (3) UTF-8编码时: 7个编码单元，61, 62, 63, f0, 90, 90, 80
编码格式区别 Unicode、GB2312都是编码字符集，即一个编号（数字）到字符的一种映射关系，仅仅是一种映射关系。
GBK、UTF-8都是编码格式。GBK和UTF-8都是用来序列化或存储Unicode编码的数据的，但是分别是2种不同的格式。除了格式不一样之外，他们所关心的unicode编码范围也不一样，UTF-8考虑了很多种不同国家的字符，涵盖整个Unicode码表，所以其存储一个字符的编码的时候，使用的字节长度也从1字节到4字节不等；而GBK只考虑中文(在Unicode中的一小部分字符的编码），所以它算好了只要2个字节就能涵盖到绝大多数常用中文(2个字节能表示6w多种字符)，所以它存储一个字符的时候，所用的字节长度是固定的。
Java中的编码 首先Java的String使用的编码是Unicode，但是当String存在于内存中时(也就是当程序运行时，你在代码中用String类型的引用对它进行操作时，也就是String没有被存在文件中且也没有在网络中传输(序列化)时)，是“只有编码而没有编码格式的”，所以Java程序中的任何String对象，说它是GBK还是UTF-8都是错的。GBK和UTF-8是编码格式而不是编码，String在内存中不需要“编码格式”(记住编码格式是在存文件或序列化的时候使用的), 它只是一个Unicode的字符串而已。
所以Java里面String是不带编码格式的，而String.toByteArray(String charsetName)得到的byteArray是带编码格式的，格式就是你传入的charsetName，我们不妨把toByteArray的这个过程叫做==编码==；另外，new String(byte bytes[], String charsetName)是把一个byte数组(带编码格式)以charsetName指定的编码格式翻译为一个不带编码格式的String对象，我们不妨把这个过程叫==解码==。
String(byte[] bytes)通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 String(byte[] bytes, Charset charset)通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。</description>
    </item>
    
    <item>
      <title>调用拷贝构造函数的场景</title>
      <link>https://devin0x01.github.io/post/cpp/%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%BA%E6%99%AF/</guid>
      <description>1.默认构造函数 默认构造函数是一个系统生成的，参数列表和函数体都为空的函数。 如果类中声明了默认构造函数（无论是否有参数），编译器便不再会为之生成隐含的构造函数。
2.析构函数 析构函数的函数列表为空，因此不能实现重载。 可以显式调用析构函数。例如可以通过对象名等进行调用，obj.~A(); 参考文献：显式调用析构函数
3.拷贝构造函数 拷贝构造函数的参数**必须是引用类型。**参数是指针不会编译报错，但是3.1中的场景不能触发调用拷贝构造函数。
3.1 调用拷贝构造函数的3种场景 用一个类的对象去初始化另一个类的对象时 Point a(1, 2); Point b(a); // 调用复制构造函数 Point c = a; // 调用复制构造函数 函数的形参是类对象，当调用函数，进行形参和实参结合时 void fun(Point obj) {} int main() { Point a(1, 2); fun(a); // 调用复制构造函数 } 如果函数的返回值是类对象，当函数执行完成返回调用者时 实际上，由于编译器的优化，可能不会调用。例如：gcc需要指定**-fno-elide-constructors**编译选项才会调用。
Point fun() { Point a(1, 2); return a; // 调用复制构造函数 } b = fun(); 4.赋值运算符 4.1 注意点 **拷贝构造函数必须以引用的方式传递参数，**基本上都是传常量引用的方式传递函数参数。 赋值运算符函数的返回值类型要声明为该类型的引用，并在函数结束前返回实例自身的的引用（this）*。**只有返回一个引用，才能进行连续赋值。否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。假设有3个Person对象：p1、p2、p3，在程序中语句p1=p2=p3将不能通过编译。 关于深拷贝和浅拷贝：当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。 4.2 和拷贝构造函数的区别 区别：拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。 #include &amp;lt;iostream&amp;gt; using namespace std; class A { public: A(string str) : name(str) { cout &amp;lt;&amp;lt; &amp;#34;construct &amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; } // 构造函数 A(const A &amp;amp;other) { // 拷贝构造函数 name = &amp;#34;copy &amp;#34; + other.</description>
    </item>
    
    <item>
      <title>重载、覆盖、隐藏</title>
      <link>https://devin0x01.github.io/post/cpp/%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F/</link>
      <pubDate>Sun, 18 Jun 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/cpp/%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F/</guid>
      <description>C++类层次中的同名函数，有三种关系：
1.重载**（overload）** 概念：相同的范围（同一个类）中的同名函数，参数列表不同。 1)与返回值类型没有关系。 2)const是有效的重载。 3)virutal是无效的重载。virtual关键字可有可无，不影响是否是重载函数。
2.重写、覆盖**（override）** 概念：在派生类中覆盖基类中的同名函数，要求 1)基类函数必须是虚函数 2)与基类的虚函数有相同的参数列表 3)与基类的虚函数有相同的返回类型、或者满足赋值兼容规则的指针/引用类型返回值(见下面的例子)。
以下情况不能实现多态：同名函数缺省参数不一致、同名函数用const修饰
3.隐藏**（hide，oversee）** 概念：隐藏指在某些情况下，派生类中的函数屏蔽了基类中的同名函数。这些情况包括两个函数参数相同，但是基类不是虚函数。&amp;mdash;（参数不同可以实现重载） 区别：和覆盖的区别在于基类函数是否是虚函数。
可以使用using声明解决基类成员被隐藏的问题，例如：
class Base { public: virtual void f(int) { std::cout &amp;lt;&amp;lt; &amp;#34;Base::f\n&amp;#34;; } void g(char) { std::cout &amp;lt;&amp;lt; &amp;#34;Base::g\n&amp;#34;; } void h(int) { std::cout &amp;lt;&amp;lt; &amp;#34;Base::h\n&amp;#34;; } protected: int m; private: int k; }; class Derived : public Base { public: using Base::m; // 此时 m 为public // using Base::k; // error报错 using Base::f; void f(int) { std::cout &amp;lt;&amp;lt; &amp;#34;Derived::f\n&amp;#34;; } // D::f(int) 覆盖 B::f(int) using Base::g; // 不声明的话，需要通过 obj.</description>
    </item>
    
    <item>
      <title>配置github pages教程</title>
      <link>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/%E9%85%8D%E7%BD%AEgithub-pages%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sat, 13 May 2023 14:05:25 +0800</pubDate>
      
      <guid>https://devin0x01.github.io/post/%E5%B7%A5%E5%85%B7/%E9%85%8D%E7%BD%AEgithub-pages%E6%95%99%E7%A8%8B/</guid>
      <description>1.基础配置 关于删除submodule: Git submodule add: &amp;ldquo;a git directory is found locally&amp;rdquo; issue - Stack Overflow
mkdir myblog &amp;amp;&amp;amp; cd myblog hugo new site . git init git submodule add git@github.com:MeiK2333/github-style.git themes/github-style vim .gitignore git add . git push -u origin master 更新主题 github-style theme
cd themes/github-style git pull 编辑readme hugo new readme.md echo &amp;#39;`Hello World!`&amp;#39; &amp;gt; content/readme.md 2.新增帖子 Hugo will create a post with draft: true, change it to false in order for it to show in the website.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://devin0x01.github.io/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://devin0x01.github.io/readme/</guid>
      <description>Blogs 程序员的喵
高性能架构探索 | 一个专注于钻研技术的网站
wenfh2020文集
腾讯云开发者社区-腾讯云
C++和STL中有哪些副作用或者稍不注意会产生性能开销的地方？ - 知乎
C++ AnthonyCalandra/modern-cpp-features
sprinfall/cpp-thread-study: C++ 线程库示例及教程
Kobzol/hardware-effects: Demonstration of various hardware effects.
yanfeizhang/coder-kung-fu: 开发内功修炼
天山老妖S的博客_性能优化_51CTO博客
plantegg/programmer_case: 程序员案例集锦
Linux 蜗窝科技
liexusong/linux-source-code-analyze: Linux内核源码分析
0voice/kernel_awsome_feature: 深入研究 kvm,ceph,fuse特性
0voice/linux_kernel_wiki: linux内核学习资料
Awesome skywind3000/awesome-cheatsheets: 超级速查表
iggredible/Learn-Vim: Learning Vim and Vimscript doesn&amp;rsquo;t have to be hard.
521xueweihan/HelloGitHub: 分享 GitHub 上有趣、入门级的开源项目。</description>
    </item>
    
  </channel>
</rss>
