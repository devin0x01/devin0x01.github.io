<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux运维 on DEVIN&#39;s BLOG</title>
    <link>https://devin0x01.github.io/tags/linux%E8%BF%90%E7%BB%B4/</link>
    <description>Recent content in Linux运维 on DEVIN&#39;s BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Mar 2024 17:02:55 +0000</lastBuildDate>
    <atom:link href="https://devin0x01.github.io/tags/linux%E8%BF%90%E7%BB%B4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>frp内网穿透配置教程</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 04 Aug 2023 16:05:25 +0800</pubDate>
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid>
      <description>重要资料 fatedier/frp - github&#xA;官方文档 | frp&#xA;司波图/自建内网穿透服务器 - 码云&#xA;$ tree /opt/frp /opt/frp ├── frpc ├── frpc_full.ini ├── frpc.ini ├── frps ├── frps_full.ini ├── frps.ini └── LICENSE 1.SSH访问内网机器 通过 SSH 访问内网机器 | frp&#xA;1.1.Server配置 在具有公网 IP 的机器上部署 frps，修改 frps.ini 文件，这里使用了最简化的配置，设置了 frp 服务器用户接收客户端连接的端口。&#xA;#/opt/frp/frps.ini [common] bind_port = 7000 # 注意：需要在云服务设置开放7000端口 # 身份验证(可选) token = i*RY2KI9^A7H # web界面 dashboard_port = 7500 # dashboard 用户名密码，可选，默认为空 dashboard_user = admin dashboard_pwd = admin 运行方式：/opt/frp/frps -c /opt/frp/frps.</description>
    </item>
    <item>
      <title>Systemd教程</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/systemd%E6%95%99%E7%A8%8B/</link>
      <pubDate>Mon, 31 Jul 2023 16:05:25 +0800</pubDate>
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/systemd%E6%95%99%E7%A8%8B/</guid>
      <description>Systemd 入门教程：实战篇 - 阮一峰的网络日志&#xA;配置文件 $ systemctl cat sshd.service [Unit] Description=OpenSSH server daemon Documentation=man:sshd(8) man:sshd_config(5) After=network.target sshd-keygen.service Wants=sshd-keygen.service [Service] EnvironmentFile=/etc/sysconfig/sshd ExecStart=/usr/sbin/sshd -D $OPTIONS ExecReload=/bin/kill -HUP $MAINPID Type=simple KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target Unit区块：启动顺序和依赖关系 Description字段给出当前服务的简单描述。&#xA;Documentation字段给出文档位置。&#xA;After字段表示如果network.target或sshd-keygen.service需要启动，那么sshd.service应该在它们之后启动。&#xA;Before字段定义sshd.service应该在哪些服务之前启动。&#xA;Wants字段表示sshd.service与sshd-keygen.service之间存在&amp;quot;弱依赖&amp;quot;关系，即如果sshd-keygen.service启动失败或停止运行，不影响sshd.service继续执行。&#xA;Requires字段则表示&amp;quot;强依赖&amp;quot;关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。&#xA;注意，After和Before字段只涉及启动顺序，不涉及依赖关系。&#xA;注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。&#xA;举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。&#xA;Service区块：如何启动当前服务 EnvironmentFile字段指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。上面的例子中，sshd 的环境参数文件是/etc/sysconfig/sshd。&#xA;ExecStart字段：定义启动进程时执行的命令。上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。&#xA;Install区块：如何安装这个配置文件，即怎样做到开机启动。 WantedBy字段：表示该服务所在的Target。Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd所在的Target是multi-user.target。 这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在/etc/systemd/system目录下面的multi-user.target.wants子目录之中。&#xA;Systemd 有默认的启动 Target，下面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。</description>
    </item>
    <item>
      <title>Docker常用命令</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 31 Jul 2023 12:05:25 +0800</pubDate>
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Docker — 从入门到实践&#xA;Docker Guide&#xA;清理Docker的container，image与volume · 零壹軒·笔记&#xA;docker docker info #docker配置信息 docker inspect $cid #查看容器的配置信息 docker images docker ps -a docker run -it $image_id --rm #rm表示退出容器后就删除该容器 docker exec -it $cid /bin/bash docker start $cid docker stop $cid docker restart $cid docker rm -f $cid docker rm -v $cid #同时删除 /var/lib/docker 目录下的数据卷 docker logs $cid #查看容器日志 docker system df #查看docker缓存大小 docker system prune docker builder prune #一键清理 Build Cache docker builder prune --filter &amp;#39;until=240h&amp;#39; #保留最近10天的缓存 docker tag ca1b6b825289 devincpp/rk3568:v1.</description>
    </item>
    <item>
      <title>WireGuard配置教程.md</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/wireguard%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sun, 30 Jul 2023 12:10:05 +0800</pubDate>
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/wireguard%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid>
      <description>Run WireGuard VPN Server in Docker Container with Docker Compose - TechViewLeo &amp;ndash; 主要参考这个&#xA;基于Wireguard技术的虚拟个人网络搭建: 基于wireguard的内网穿透技术~&#xA;搭建WireGuard-腾讯云开发者社区-腾讯云&#xA;公网机器: IP=100.101.102.103, Name=TencentVM1 私网机器: IP=192.168.123.189, Name=LocalMint1 1.服务端配置 1.1.安装wg-easy镜像 wg-easy/wg-easy: The easiest way to run WireGuard VPN + Web-based Admin UI.&#xA;基于Wireguard技术的虚拟个人网络搭建: 基于wireguard的内网穿透技术~&#xA;Wireguard 全互联模式（full mesh）配置指南 – 云原生实验室 - Kubernetes|Docker|Istio|Envoy|Hugo|Golang|云原生&#xA;这个新建的容器内会多一个wg0网卡，IP地址是10.0.8.1，而且网卡只在容器内可见。&#xA;server的配置文件会放在/opt/wg-easy目录下。TCP的51821端口用于访问WebUI。&#xA;docker run -d \ --name=wg-easy \ -e WG_HOST=123.123.123.123 (🚨这里输入服务器的公网IP) \ -e PASSWORD=passwd123 (🚨这里输入你的密码) \ -e WG_DEFAULT_ADDRESS=10.0.8.x （🚨默认IP地址）\ -e WG_DEFAULT_DNS=114.114.114.114 （🚨默认DNS）\ -e WG_ALLOWED_IPS=10.0.8.0/24 （🚨允许连接的IP段）\ -e WG_PERSISTENT_KEEPALIVE=25 （🚨重连间隔）\ -v /opt/wg-easy:/etc/wireguard \ -p 51820:51820/udp \ -p 51821:51821/tcp \ --cap-add=NET_ADMIN \ --cap-add=SYS_MODULE \ --sysctl=&amp;#34;net.</description>
    </item>
    <item>
      <title>Docker内显示图形界面</title>
      <link>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/docker%E5%86%85%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</link>
      <pubDate>Fri, 28 Jul 2023 16:05:25 +0800</pubDate>
      <guid>https://devin0x01.github.io/post/linux%E8%BF%90%E7%BB%B4/docker%E5%86%85%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</guid>
      <description>关于X11 x(7) - Linux man page&#xA;Cygwin系列（十二）：了解X - 知乎&#xA;X11采用了C/S的架构，在其设计下，整个图形视窗系统主要分为3个部分：&#xA;1.X Server（X服务器）。X Server一方面负责和设备驱动交互，监听显示器和键盘鼠标，另一方面响应X Client需求传递键盘、鼠标事件、（通过设备驱动）绘制图形文字等。反直觉之一，X Server运行在本地。&#xA;2.X Client（X客户端）。X Client也叫X应用程序，负责实现程序逻辑，在收到设备事件后计算出绘图数据，由于本身没有绘制能力，只能向X Server发送绘制请求和绘图数据，告诉X Server在哪里绘制一个什么样的图形。X Client可以和X Server在同一个主机上，也可以通过TCP/IP网络连接。&#xA;3.Window Manager（窗口管理器，简称WM），或者叫合成器（Compositor）。多个X Client向X Server发送绘制请求时，各X Client程序并不知道彼此的存在，绘制图形出现重叠、颜色干扰等问题是大概率事件，这就需要一个管理者统一协调，即Window Manager，它掌管各X Client的Window（窗口）视觉外观，如形状、排列、移动、重叠渲染等。反直觉之二，Window Manager并非X Server的一部分，而是一个特殊的X Client程序。&#xA;3个部分， X Server是整个X Window System的中心，协调X客户端和窗口管理器的通信。&#xA;常用命令 xorg - What does $DISPLAY environment variable mean - Ask Ubuntu&#xA;x11 forwarding - How to fix &amp;ldquo;MobaXterm X11 proxy: Unsupported authorisation protocol&amp;rdquo; - Super User&#xA;echo $DISPLAY # 注意：`xauth add` 之后可能需要重新连接才能生效!! xauth add $DISPLAY .</description>
    </item>
  </channel>
</rss>
